# javascript

目录
[toc]


## 初识js 
### 1、什么是 JavaScript？
　　JavaScript 是一门跨平台、面向对象的动态的弱类型的轻量级解释型语言，是一种基于对象和事件驱动并具有相对安全性的客户端脚本语言。应用于 HTML 文档能够在网站上提供动态的交互能力，他不同于 Java。简单说就是基于浏览器处理 HTML 文档，实现各种网页特效，响应用户的各种操作，为网页添加动态效果，提升用户操作体验，比如图片滚动播放效果，点击登录按钮弹出对话框，鼠标移入移出动画，表单提交数据验证等。

### 2、为什么要学习 JavaScript？
　　JavaScript 通常被称为 JS，他发明的目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力，他可以让网页呈现出各种特殊效果，为用户提供友好的互动体验。随着 Ajax 技术的出现，前端可以在不刷新页面的情况下和后端进行数据交换，更新页面数据，jQuery 等库的盛行让 JS 编写变得异常简单，Bootstrap 框架更让前端的成本无限降低，大大提高了前端开发的效率，JS 在前端领域前景非常广阔。

　　随着 Node 的发布，使得 JS 不仅可以运行在前端，还可以运行在服务器上。这对 JS 来说是一次质的突破，Node.js 项目使得 JS 可以用于开发服务器端的大型项目，网站的前后端都用 JS 开发已经称为了现实。

　　至此 JS 除了可以被浏览器解析，也可以作为后端语言使用，越来越多的应用程序，将 JS 作为内嵌的脚本语言，可以用来构建移动端 APP，开发 HTML 游戏，可以不依赖于浏览器，构建桌面应用程序。

　　可以预期，最终只使用 JS 这一种语言，就可以开发出适应不同平台（包括桌面端，服务器端，手持端）的程序。在 Jeef Atwood 发布的博客中，他提出了著名的“Atwood定律”，即“任何能够用 JavaScript 实现的应用程序，最终都必将用 JavaScript 实现”。

　　相比学习其他语言，JS 很容易学习。只要有浏览器，就能运行 JS 程序，只要有文本编辑器，就可以编写 JS 代码。不用安装复杂的 IED（集成开发环境）和编译器。JS 的语法相对简单一些，本身的语法不是特别多，而且语言灵活，完全可以只用简单的命令，完成大部分的操作。

　　虽然 JS 的核心语法不难学习，但是要真正学透还不是一件容易的事，JS 其实是很复杂的，随着学习，越能体会到他的强大。JS 要发挥作用，必须与其他组件配合，这些外部组件五花八门，而且数量庞大，涉及到了网络应用的各个方面，比如编辑器组件，QQ 空间提供的关注组件等，要掌握他们并非易事，必须下狠功夫。JS 语言有一些设计缺陷，在一些地方会出现怪异的运行结果，各主流浏览器对于 JS 的支持不尽相同，兼容性是最让人头疼的事情，学习 JS，很大一部分时间都是用来搞清除哪些地方有陷阱。

　　尽管如此，JS 的地位还是不可动摇的，2015年公布的世界语言使用排名，JS 排在第七位，较去年又有了提升。Ecma（通过 Ecma-262 制定脚本语言的标准）加快了语言的标准化，使得 JS 功能日益增强，而语法缺陷和怪异之处也得到了弥补，截至今年 JS 最新版本为 ECMAScript 2015，也叫 ES6，增加了许多新特性。所以，JS 还是值得学习的，不仅要掌握，而且要学精，尤其对于 Web 前端开发工程师尤为重要。

### 3、JavaScript 组成
　　JS 由三部分组成：

　　ECMAScript：也叫解释器，充当翻译角色，这是 JS 的核心部分。

　　DOM：文档对象模型（Document Object Model）。DOM 赋予了 JS 操作 HTML 的能力，即 document 操作。

　　BOM：浏览器对象模型（Browser Object Model）。BOM 赋予了 JS 操作浏览器的能力，即 window 操作。

### 4、JavaScript 用法

　　HTML 中的脚本必须位于 <script></script> 标签之间。可以在 HTML 文档中放入不限数量的脚本。脚本可位于 HTML 的 <head>或<body> 中，或者同时存在于这两个部分中。通常的做法是把函数放在 <head> 中，或者放在页面底部，这样不会干扰页面的内容。

　　也可以把脚本保存在外部文件中，文件扩展名为 .js，外部文件通常包含被多个网页使用的代码。注意：在使用外部脚本时，脚本内不能包含 `<script>` 标签。

### 5、编写 JavaScript 的流程
　　首先，也是最重要的，先要搞清楚网页效果的实现原理，要达到什么目的，需要对哪些属性做出修改，以及用户的哪些操作，通过用户的某种操作，一步步的构思 JS 实现的方法。

　　然后 HTML+CSS 布局页面。

　　接着选择需要修改的属性的名称（id 或 class）。

　　再根据用户的操作，选择相应的触发事件。

　　最后，在事件中，根据第一步的构思，编写 JS 代码。


## js基础

### 1、JS 命名规范
　　命名规范是很有必要的，可增强代码的可读性，一眼就能看懂要表达的意思，规范就是符合规则，使代码有利于后期维护，也能很大程度的提高开发效率。一个正常的网站有很多 JS 代码，如果在编写的过程中，不遵循某种规则，那么写到后面自己都看不懂自己写的什么，这是很麻烦的一件事，所以要在平时的练习过程中，养成良好的编写代码的习惯。

　　一般都采用匈牙利命名法或者驼峰命名法。

　　匈牙利命名法的原则：变量名=属性+类型+对象描述。他的关键是：以一个或多个小写字母作为前缀，前缀之后是一个或多个首字母大写的单词组合，该单词指明变量的用途。

　　驼峰命名法的原则：第一个单词以小写字母开始，之后每一个单词的首字母大写。例如：myFirstName、myLastName，这样的变量名看上去就像驼峰一样此起彼伏，因此得名。驼峰法的关键是：除第一个单词外，其他单词首字母大小，混合使用大小写字母来构成变量名和函数名，还可以使用下划线来形成逻辑断点，这样更能增强代码的可读性。

　　使用什么样的命名规范，还要要看个人喜好，或者公司规定。注意：在命名时不能使用保留字和太长不容易记忆的名称，要避免使用两个相似的变量名。下面是一些常用的匈牙利命名法的前缀：

|类型    |前缀|	类型|	实例|
--------|----|----|-|
数组     |	a|	Array|	aItems（项目）
字符串   |	s|	String|	sUserName
函数     | fn|	Function|	fnHandler（处理程序）
对象     |  o|	Object|	oDiv
整数     |	i|	Integer|	iItemCount（项目计数）
浮点数   |	f|	Float|	fPrice（价格）
布尔值   |	b|	Boolean|	bIsComplete（完成）
正则表达式|	re|	RegExp|	reEmailCheck（邮件检测）

### 2、注释很重要
　　JS中单行注释用“ // 注释内容” 标识，多行注释使用“  /* 注释内容 */  “标识。注释的作用是提高代码的可读性，不仅自己以后用着方便，也有助于别人阅读和理解你所编写的JS代码，注释中的内容不会在网页中显示。为了方便阅读，注释一般放在需要解释的语句结尾处或者周围。在学习的过程中，我们更要养成书写注释的良好习惯，有利于我们对于代码的理解，或者标记出当时比较模糊的概念，回头再做深入的定向学习，更牢固的掌握该知识点。

### 3、JS 语句和符号
　　JS 语句是发送给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。JS 的执行规则是自上往下以行为单位的，一般情况下，每一行就是一个语句。比如：var a = 1+2;  这条语句先用 var 关键词，声明了变量 a，再将 1+2 的运算结果赋值给变量 a。这里需要注意 = 符号，在 JS 中并不是等号的意思，而是赋值。再比如：alert('hello');  这是一条 JS 语句，一行的结束被认定为语句的结束，通常在结尾加上一个 ; 来表示语句的结束，如果有多行 JS 语句，每句结束都有 ;，则按顺序执行语句。注意：JS 中的代码和符号都必须在英文状态下输入，虽然 ; 也可以不写，但难免会遇到一些错误，浏览器会判定前一句和后一句是可以连在一起解释的，这样就导致了一些意想不到的错误。我们要养成良好的编程习惯，记得在必须加分号的地方一定不要忘记加上。

　　JS 对大小敏感，在编写JS代码时，需要留意是否关闭了大小写切换键。
 
### 4、JS 判断语句和 for 循环
　　if 判断语句和 for 循环在 JS 中使用非常频繁。

　　通常在写代码时，总是需要为不同的决定来执行不同的动作，在代码中就可以使用 if 条件语句来完成该任务。

　　在 JS 中，可以使用以下条件语句：

　　(1)、if 语句：只有当指定条件为 true 时，也就是条件成立时执行的代码。

　　(2)、if... else 语句：当条件成立时执行 if 后代码，条件不成立(为 false )时执行 else 后的代码。

　　(3)、if... else if.... else 语句：使用该语句根据判断条件来选择多个代码块之一来执行。

　　实例：根据不同的时间，提示不同的问候，当时间小于12点，问候早上好，当时间大于或等于12点小于18点，问候下午好，否则都问候晚上好。

```
 1 <script>
 2 var d = new Date();
 3 var time = d.getHours();
 4 if (time < 12){
 5     alert('早上好');
 6 }
 7 else if (time >= 12 && time < 18){
 8     alert('下午好');
 9 }
10 else{
11     alert('晚上好');
12 }
13 </script>
```
 
　　如果希望一遍又一遍的运行相同的代码，并且每次的值都不同，那么使用循环是很方便的，当有一组元素的时候，就可以使用 for 循环为这一组元素添加事件。

　　for循环的语法：
```
1 for (语句 1; 语句 2; 语句 3){
2   被执行的代码块
3 }
4 
5 语句1用于初始化循环中所有的变量。通常为：var i=0;
6 语句2用于设置初始变量的条件。通常为：i<object.length;
7 语句3用于增加初始变量的值。通常为：i++ 也可以为：i--
```
　　实例：循环遍历数组中的数据，依次输出：
```
 1 //在不使用循环时，我们可以这样输出数组中的值：
 2 var cars=["路虎","宝马","奔驰","奥迪","别克","大众"];
 3 document.write(cars[0] + "<br>"); 
 4 document.write(cars[1] + "<br>"); 
 5 document.write(cars[2] + "<br>"); 
 6 document.write(cars[3] + "<br>"); 
 7 document.write(cars[4] + "<br>"); 
 8 document.write(cars[5] + "<br>");
 9 
10 //使用for循环可以很简洁的完成输出：
11 for (var i=0, i<cars.length; i++){
12     document.write(cars[i] + "<br>");
13 }
```
　　document.write() 可用于直接向 HTML 输出流写内容，可以在平时做练习时用于向页面输出内容测试代码，这里需要注意 document.write() 一定要向文档输出写内容，如果文档已经加载完成后，再来执行该语句，则整个页面将会被覆盖。如果 document.write() 放在事件中，则会先清空页面上所有的内容，然后再写入内容。

### 5、JS 一些基本概念
　　(1)、标识符：标识符是 JS 中定义的符号，可以由任意顺序的大小写字母、数字、下划线、和美元符号( $ )组成。标识符就是识别一个具体对象的名称，最常见的标识符就是变量名和函数名，JS对大小写敏感，所以 a 和 A 是两个不同的标识符。标识符不能以数字开头，也不能是JS中的保留关键字，具体可百度参考资料。另外还有三个虽然不是保留字，但是因为他们具有特别的含义，也不能用作标识符：Infinity、NaN、undefined。

　　(2)、代码块：代码块其实不难理解，先来解释以下 JS 代码，JS 代码就是 JS 语句的序列，浏览器依据编写 JS 语句的顺序依次逐行的执行每个语句，而代码块则是 JS 语句的组合，并且包含在花括号内，代码块的作用是告诉浏览器这些代码一起执行语句序列。JS 函数就是将语句组合在块中的典型例子。

　　(3)、变量：从字面上来理解，变量就是可以改变的量，但是从编程角度讲，变量是用于存储某种/某些数值信息的“容器”，简单说就是对“值”的引用，使用变量等同于引用一个值，每一个变量都有一个变量名。比如：var x = 1; 先声明一个变量 x，x 就是变量名，然后用 = 赋值，也就是将 1 赋值给 x，以后，在引用 x 的时候，就会得到值 1。在 JS 中创建一个变量通常被称为“声明”一个变量，var 就是用来声明变量的。变量在声明之后是空的，他的值为undefined（未定义），需要给他赋值后使用，= 就是建立这种引用关系。上面的代码可以看作为：var x；x=1；这样写是先声明一个变量，再给其赋值，上面的代码则在声明的同时就进行了赋值。在一条语句中，可以声明多个变量，并使用逗号隔开。注意：在给变量命名的时候不能使用 JS 关键词和 JS 保留词。

　　(4)、常量：有变量就会有常量，变量可以理解为变化的量，而常量就是不变的量。其实在 JS 中并没有常量这个概念，所谓的常量，只不过是提前赋值的变量而已。常量和变量都属于变量，只不过常量是赋过值后就不能再改变的变量，而普通的变量可以再次进行赋值操作。为了与变量有所区分，增强代码的可读性，所以在声明一个常量时，一般采用常量名全部大写，若有多个单词，可用下划线隔开。

　　(5)、字面量：所谓的字面量，其实是对象的表示形式，或者说是创建方式，他不是一种值，而是一种表示值的记法，简单说字面量就是如何表达一个对象的值，在给变量赋值时，赋值运算符后面的都可以认为是字面量。字面量也叫直接量，一个字面量，也可以被认为是一个常量，如 100。这里需要注意：变量是一个名称，而字面量是一个值。字面量可分为：数字字面量、字符串字面量和表达式字面量。数字字面量，可以是整数或者是小数，比如：var a=10; var b=3.14; 10 和 3.14 就是数字字面量。字符串字面量，使用引号包含起来的一系列字符，比如：var str='小明'； '小明'就是字符串字面量。表达式字面量又可分为：数组字面量、对象字面量、函数字面量。数组字面量，每个值用逗号隔开，比如：var arr = [1,2,3,4,5,6];  [1,2,3,4,5,6] 就是数组字面量。对象字面量是一个键值对的组合，每个键值对之间用逗号分割，并包含在花括号内，比如：var obj = {a:12, b:5, c:'21'}， {a:12, b:5, c:'21'} 就是对象字面量。函数字面量，function myFunction(a, b) { return a * b;} 函数字面量是用关键字 function 后加可选的函数名、用圆括号括起来的参数和用花括号括起来的执行语句构成。函数字面量是一个表达式，而不是语句。上面的例子可写为：var myFunction = function (a, b)  { return a * b;} ，这样就有便于理解了，也可以说函数的字面量就是一个匿名函数，他的指向是归谁使用。

　　(6)、变量的作用域：变量分为：全局变量和局部变量。全局变量简单说就是在函数外声明的变量，任何地方都可以使用，而局部变量就是在函数内部声明的变量，只能在声明他的函数内部使用。这就是变量的作用域，通俗理解就是他的作用范围。JS 变量的生命期从他们被声明的时候开始，全局变量会在页面被关闭之后删除，局部变量则在函数被运行以后删除。

　　(7)、表达式：表达式与数学中的定义相似，是指具有一定的值、用运算符把常量和变量连接起来的代数计算式，一个表达式可以包含常量或变量。比如：var a=a+1;  a 是变量名称，a+1 就是表达式。在生活中”再见“表达方式有很多种，比如：英语(goodbey)，网络语(886)，肢体语言(摆摆手)等。JS 中的表达式无处不在，可以表达以下几种内容：字符串的连接，被称为串表达式，var str = "I" + "love" + "you";  还有这种形式：var str = "hello"; var str1 = str + "World";  串表达式值为字符串。数值表达式，var num = 10 + 2.5;  也有如下形式：var num = 10 + 2.5; var num1 = num + 10 * 2.5;  数值表达式值为数值。还是有一种是布尔表达式，var num = 2; alert(num == 2); 返回 ture，alert(num > 10); 返回 false。布尔表达式值为 true 或 false。

　　(8)、函数：一看到函数，很多人可能就头疼，但是编程中函数还是很好理解的，是由事件驱动的或者当它被调用时执行的可重复使用的代码块。简单说就是完成某个特定功能的一组语句，使用function关键字定义包裹在花括号中的代码块，便于反复调用。其基本形式为：function moveStart(){代码} 。声明一个函数只是在告诉浏览器这有一个函数，不会被实际执行，而在函数调用的时候，才真正执行函数内的代码。moveStart 就是函数名，遵循 JS 命名规范，在函数调用的时候使用：moveStart()。若将函数定义在变量后，变量则可作为函数使用。函数存储在变量中，不需要函数名，可以通过变量名调用。我们把没有名称的函数称为匿名函数。函数返回值，函数执行的结果就是函数返回值，return 可以将函数内的结果返回到函数外调用，在使用 return 语句时，函数会停止执行，并返回指定的值，再从调用的地方开始执行，函数调用会被返回值取代，同样一个函数应该只返回一种类型的值，在仅仅是希望退出函数时，也可以使用 return，返回值是可选的，比如下面的代码：如果 a 大于 b，则退出函数，并不会计算 a 和 b 的和。
```
1 function myFunction(a, b){
2     if (a > b){
3         return;
4     }
5     x = a+b;
6 }    
 ```

　　(9)、函数传参：在调用函数时，可以向其传递值，这些值被称为参数，这些参数可以在函数中使用，可以传递任意多的参数，并由逗号分割，比如：function myFunction(x, y){return x * y;} ，在调用的时候传入值：myFunction(3 ,4)，则返回 x乘y 的运算结果。简单理解，参数就是一个占位符，即先把位置占住，后面再用。传递的值必须与参数以一致的顺序出现，第一个值就是第一个被传递的参数给定的值，依次类推。函数很灵活，可以传递不同的值，来调用该函数。函数参数可分为：显式参数和隐藏参数( arguments )。函数的显式传参，也叫固定参，就是在函数被声明定义的时候列出的参数。隐藏参数也叫可变参，或者不定参，arguments 对象是 JS 内置的对象，对象包含了函数调用的参数数组，通过这一点可以很方便的找到最后一个参数的值，或者计算所有参数的和。当函数里有一部分定不下来的时候可以用函数传参，举一个简单的例子：点击按钮改变 DIV 的样式：

```
 1 <style>
 2 #div1{
 3     width:200px;
 4     height:200px;
 5     background:red;
 6 }
 7 </style>
 8 <body>
 9 <div id="div1"></div>
10 <input type="button" value="变宽" onclick="setWid('width','400px')" />
11 <input type="button" value="变高" onclick="setWid('height','400px')" />
12 <input type="button" value="变绿" onclick="setWid('background','green')" />
13 <script>
14 function setWid(name, value){    //函数传参
15     var x = document.getElementById('div1');
16     x.style[name] = value;
17 }
18 </script>
19 </body>
```
 　
```
 1 //参数求和：
 2 <script>
 3 function sumArr() {
 4     var result = 0;
 5     for(var i = 0; i < arguments.length; i++) {
 6         result += arguments[i];
 7     }
 8     return result;
 9 } 
10 alert(sumArr(3,5,2,12,8,51,99));    //和为：180
11 </script>  
```

　　(10)、对象：在现实生活中，一个人可以被视为一个对象，对象有他的属性，比如性别、身高、年龄，籍贯等，方法有：走、跑、跳等。所有的人都有这些属性，但是每个人的属性又不尽相同，所有的人都有这些方法，但是他们执行的时间都不尽相同。在 JS 中，对象就是拥有属性和方法的数据，JS 中的所有事物都是对象：字符串、日期、数组、数字等等。可以说在 JS 中一切皆对象，属性是与对象相关的值，方法是能够在对象上执行的动作。简单说对象只是带有属性和方法的特殊数据类型。在 JS 中对象是数据（变量），拥有属性和方法，当在声明一个变量时，var txt = "你好"； 实际上已经创建了一个字符串对象，该对象拥有 length 属性，字符串对象同时拥有很多个内置的方法，比如：charAt() 可获取某个字符，返回字符串的某一位的字符。可以说 JS 对象是变量的容器，但是，通常认为 JS对象是键值对的容器，键值对的写法为：name:value，键与值以冒号分隔，键值对又常被称为对象属性，所以 JS 对象就是属性变量的容器。JS支持自定义对象，可以通过 new 关键字创建。

### 6、JS 数据类型
　　JS 数据类型可分为基本数据类型和复合数据类型两种，其中基本数据类型有五种：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）。复合数据类型即 Object，Object 本质是一组无序的名值对组成的，严格来说，又被分为三类：对象(Object)、数组(Array)、函数（function）。

　　(1)、字符串：字符串是存储字符的变量。比如：var a='小明';，字符串可以是引号中的任意文本，可以使用单引号或者双引号。

　　(2)、数字：数字就是用来存储数字的变量。可以为整数也可以是小数。比如：var a1=314; var a2=3.14；。

　　(3)、布尔：布尔值是 "ture" 真和 "false" 假两个特定值，布尔常用在条件测试中。

　　　　什么是真 ture：非零数字、非空字符串、非空对象

　　　　什么是假 false：数字零、空字符串、空对象(null)、undefined　　

　　(4)、Null：null 是一个只有一个值的特殊类型，表示一个空对象引用，可以用来清空变量。

　　(5)、Undefined：表示为定义，有两种情况：1：真的没有定义。2、虽然定义了，但是没有赋值。

　　(6)、Object：对象由大括号包含。在括号内部，对象的属性以名称和值对的形式{name : value}来定义。属性由逗号分隔，包括了除数字、字符串和布尔值以外的所有类型。比如：var person = {name:"小明", sex:"男", id:5566};，此例子中的对象（person）有三个属性：name， sex，id。

　　(7)、Array：使用单独的变量名来存储一系列的值。创建一个数组的方法：var arr = new Array();，之后可以给数组添加值：arr[0] = 1; arr[1] = 2; arr[2] = 3;，数组的下标是基于零的，所以从 0 开始算起。在 JS 中，很多时候，要避免使用 new 关键字，所以将数组创建为：var arr = [1,2,3] 的形式。

　　(8)、function：函数其实是处理数据的方法，JS 将函数视为一种数据类型，可以像其他数据类型一样，进行赋值和传递，这就为编程带来了很大的灵活性。

　　变量的类型：变量本身是没有类型的，取决于他里边存储的什么数据类型，存的什么类型就是什么类型的变量。当声明新变量时，可以使用 new 来声明其类型，比如：var userName = new String;  var x = new Number;  var y = new Boolean;  var cars = new Array;  var person = new Object; 。JS 变量均为对象，当声明一个变量时，就创建了一个新的对象。

　　typeof运算符：typeof 操作符用来检测变量的数据类型，返回一个字符串。字符串、数字、布尔值分别返回 string、number、boolean。用 typeof 检测 null 返回 object，在 JS 中 null 表示什么都没有，但是他是一个对象。undefined 是没有赋值的变量，所以 typeof 一个没有值的变量会返回 undefined。typeof 一个对象则返回 object。JS 中数组是一种特殊类型的对象，所以也返回 object。函数则返回 function。

　　undefined 和 null 的区别：typeof undefined，返回 undefined。typeof null，返回 object。(null === undefined)，返回 false，(null == undefined)，返回true。


### 7、JS 运算符

　　**(1)、算数运算符：**

　　除了平时常见的加减乘数之外，JS 中还有一些其他的运算符：

　　**取模运算符：**%，取模通俗理解就是取余数，比如：5%2，值为1，5除2，商2余1。

　　**自增运算符：**++，自增运算分为两种情况，一种是先赋值再运算，一种是先运算再赋值。实例：假设 a = 2

　　　　先赋值再运算：var b = a++; 运算结果为：b=2，a=3 解析：b = a，a = a+1。

　　　　先运算再赋值：var b = ++a；运算结果为：b=3，a=3 解析：a = a+1，b = a。

　　通过上面的例子，可以看到，先赋值再运算，实质是先把 a 赋值给 b，然后自己再加 1。先运算再赋值，实质是先自己加 1，再把值赋给 b。

　　他们的相同点都是自增1，a = a+1，都被作为一个整体表达式运算，即 (a++)(++a)，虽然他们的值都自增 1，但是 (a++) 取 a 自增前的值，而 (++a) 取 a 自增后的值。

　　**自减运算符：**--，自减运算符和自增运算符一样，即每次自减1。也分为两种情况：实例：假设a=2

　　　　先赋值再运算：var b=a--; 运算结果为：b=2，a=1 解析：b=a，a=a-1。

　　　　先运算再赋值：var b=--a；运算结果为：a=1，b=1 解析：a=a-1，b=a。


　　　　+ 运算符可用于字符串变量的连接，若需要把多个字符串连接起来，就可以使用 + 运算符。

　　　　如果把字符串和数字相加，则得到一个字符串。比如：var str='hello'+2; 返回：hello2

　　**(2)、赋值运算符：**

　　赋值运算符用于给变量赋值。有以下几种：= += -= *= /= %=

　　　　实例：假设 a=10 b=5

　　　　=：a = b 结果：5

　　　　+=：a += b，相当于：a = a+b 结果：15

　　　　-=：a -= b，相当于：a = a-b 结果：5

　　　　*=：a *= b，相当于：a = a*b 结果：50

　　　　/=：a /= b，相当于：a = a/b 结果：2

　　　　%=：a % b，相当于：a = a/b 结果：0 (取模运算是取余数)

　　**(3)、比较运算符：**

　　比较运算符在条件语句中使用，用于判断变量或值的关系，返回 ture 或 false。

　　比较运算符有以下几种：== === != !== > < >= <=

　　　　实例：假设 a=2

　　　　==：等于。注意双等号在JS中才表示等于，一个等号为赋值。比较：a == 2，返回 ture。a == 1，返回false。

　　　　===：绝对等于，值和类型均相等。比较：a === '2'，返回 false。a === 2，返回 true。

　　　　!=：不等于。和等于相反。比较：a != 2，返回 false，a != 1，返回 ture。

　　　　!==：绝对不等于，和绝对等于相反，值和类型均不相等。比较：a !== '2'，返回 ture，a !== 2，返回 false。

　　　　>：大于。比较：a>5，返回false。

　　　　<：小于。比较：a<5，返回ture。

　　　　>=：大于等于。比较：a>=5，返回false。

　　　　<=：小于等于。比较：a<=5，返回ture。

　　**(4)、逻辑运算符：**

　　逻辑运算符用于描述变量或值之间的逻辑关系。

　　逻辑运算符有以下几种：&& || !

　　　&&：并且。在数学中我们将 b 大于 a、b 又小于 c 表示为：a<b<c，但是在 JS 中要用 && 表示：b>a && b<c。两个条件必须同时满足，则返回 ture，有一个条件不满足，则返回 false。实例：判断一个数字是否为两位数：a>9 && a<100，假设 a=50，则返回：ture。

　　　||：或。当两个条件中，有任一个条件满足，逻辑或的运算结果就为真。实例：a=5，b=10，判断c=a<b || a==b，c的值为：ture。

　　　!：否。也叫逻辑非操作符，是非颠倒，好比小明买了一本 JS 书籍，小白说：是乌龟书；小红说：是犀牛书。小明说：小白说的不是真话，小红说的不是假话。那么是小红说对了，小明买的书是犀牛书。实例：a=10 b=5，判断c =! (a>b)，c 的值为：false。

　　**(5)、三元运算符：**

　　三元运算符也叫条件运算符，其基本形式可用 if 判断语句表示，用三元运算符表示为： ？ ：。

　　所谓三元运算符，顾名思义就是需要进行三次操作，语法为：条件?结果1:结果2 。条件写在问号之前，后面跟着用冒号分隔的结果1和结果2，当满足条件时为结果1，否则就是结果2。好比你去看演唱会，条件就是需要入场券，若你带了就可以直接进去，如果没带那就请回吧，用三元运算符可表示为：带没带入场券 ? 带了直接进去 : 没带那就请回吧。

　　所有使用 if 判断语句的地方，都可以使用三元运算符，使用 if 判断语句代码比较繁琐，使用三元运算符，代码则十分简洁，但是对于初学者来说，三元运算符不是那么直观，使用 if 判断语句更容易理解，随着学习的不断深入，以及理解的加深，就可以使用三元运算符代替 if 了。

　　　　实例：判断一个数为偶数还是奇数。假设：a=12

　　　　先用 if 判断语句表示：
```
1 var a = 12;
2 if(a%2 == 0){
3     alert('a为偶数');
4 }
5 else{
6     alert('a为奇数');
7 }
```
　　　用三元运算符可表示为：
```
1 var a = 12;
2 a%2===0 ? alert('偶数') : alert('奇数');
```
 　　(6)、运算符之间的优先级：

　　从高到低依次为：算术操作符 → 比较操作符 → 逻辑操作符 → "="赋值符号

　　同级的运算是按从左到右依次进行运算，若有括号，从多层括号由里向外进行运算。

　　　　实例：

```
1 var numA = 2;
2 var numB = 5;
3 
4 var numC = numA + 40 > 10 && numB * 2 < 20;
5 var numD =( ( numA + 40 )  /  ( 12 - numB ) ) * 10;
6 
7 alert(numC);    //返回：ture
8 alert(numD);    //返回：60
```
 　　

### 8、JS 事件
　　HTML 事件是发生在 HTML 元素上的事情。当在 HTML 页面中使用 JS 时，JS 可以触发这些事件。事件可以是浏览器行为，也可以是用户操作行为，用户操作行为可分为鼠标操作和键盘操作。比如：在页面加载完成时触发事件，这属于浏览器行为，用户的操作行为如点击按钮触发事件，鼠标的移入移出，按键提交信息等。

　　下面是一些常用的事件列表：

事件	描述
onload	页面已完成加载时触发事件
onresize	调整浏览器大小时触发事件
onchange	当元素改变时触发事件
onfocus	当元素获得焦点时触发事件
onselect	当选取元素时触发事件
onsubmit	用户提交表单时触发事件
onclick	点击鼠标时触发事件
onmouseover	鼠标移入时触发事件
onmouseout	鼠标移出时触发事件
onmousedown	按下鼠标时触发事件
onmouseup	松开鼠标时触发事件
onmousemove	移动鼠标时触发事件
onmousewheel	用户滚动鼠标滚轮时触发事件
onscroll	当滑动滚动条时触发事件
onkeydown	用户按下键盘按键时触发事件
onkeyup	用户松开按键时触发事件
 

### 9、JS 常用的互动方法
　　在 JS 中可以创建三种类型的消息框：警告框、确认框、提示框。

　　(1)、警告框

　　警告框常用于确保用户可以得到某些信息，平时我们在访问网页的时候，有时突然弹出一个小窗口，上面写这一些提示文字，这就是警告框，在警告框出现之后，用户必须点击确定按钮后才能继续操作，否则就不能对网页做出任何操作。这样的弹出窗口是用”alert“实现的。

　　语法：alert(str或var);

　　(2)、确认框

　　确认框常用于验证用户是否接受操作，允许用户做出选择，当确认框弹出时，用户可以点击”确定“或者”取消“来确定用户操作，当用户点击确定时，返回值为 ture，如果点击取消，则返回值为 false。用户在点击对话框之前不能进行任何操作。这样的弹出窗口是用”confirm“实现的。

　　语法：confirm(str);

　　(3)、提示框

　　提示框也叫提问框，用于提示用户在进入页面前输入某个值，主要是询问一些需要与用户交互的信息，提示框包含一个确定、取消按钮，和一个文本框，当提示框弹出后，用户需要输入某个值，然后点击确定或者取消才能继续操作，当用户点击确认时，返回值为文本框输入的值，如果用户点击取消，则返回值为null。提示框可以和确认框相互配合使用。这样的弹出窗口是用”prompt“实现的。

　　语法：prompt(str1, str2);

　　str1 为要显示在对话框的值，也就是与用户交互的内容描述，不可修改。str2 为文本框中提示用户输入的默认内容，可以修改。

　　一般情况下，在实际的网站中，这些对话框都很少或者说几乎不使用，尤其是警告框，因为用户会反感这种突然弹出来的东西，在弹出对话框后用户不点击按钮之前，浏览器就跟死了一样，不能做任何操作，确认框和提示框相对来说还有一些使用，也是比较有意义的，比如页面中一个跳转按钮，如果不使用确认对话框，则直接跳转到新页面，使用确认对话框之后，用户可以点击确认或者取消来执行对应操作，确认则跳转新页面，取消则继续浏览，有时候这个跳转按钮或者链接是用户不小心点到的，并不希望跳转。大部分网站中，都使用的是一套自定义的对话框，更友好的显示。

### 10、JS 转义字符
　　在 JS 中字符串通常用单引号或双引号包含起来，比如：var txt = "谁看到"小明"今天来上课了吗？"; 所以这个例子会解析错误，从 "谁看到" 被截断，浏览器报错提示：语法错误，而且这是很严重的错误，错误到代码将被终止，后面的代码无法执行。其实这个例子还是很好解决的，我们可以将其用单引号括起来，再给小明加上双引号，OK，跟原来要表达的一样，但是如果我们需要换行呢？这时候就需要用到转义字符，转义字符在 JS 中应用十分广泛，尤其是在正则表达式 (RegExp) 中，因此上面的代码应该写为： var txt = "谁看到 \"小明 \"今天来上课了吗？";  需要换行则写为：var txt = "谁看到 \"小明 \" \n 今天来上课了吗？"; 。

　　反斜杠(\)是一个转义字符，转义字符可用于将特殊字符转换为字符串字符，可以用于转义撇号、引号、换行等其他特殊字符，在编写代码时需要注意特殊字符问题，很多运行时出现的问题都是因为特殊字符而引起的，由于反斜杠本身被用作转义符，因此不能在代码中只键入一个 \ ，如果需要显示一个反斜杠，必须一次键入两个 \\ 。下面是一些常用的转义字符：

转义代码	输出
\'	单引号
\"	双引号
\\	反斜杠
\n	换行符
\r	回车符
\b	退格符
\t	tab制表符
\f	换页符

## JS对象

在 JS 中一切皆对象，并提供了多个内置对象，比如：String、Array、Date 等，此外还支持自定义对象。对象只是一种特殊类型的数据，并拥有属性和方法，属性是与对象相关的值，方法是能够在对象上执行的动作。


### 1、String 对象
　　String 对象用于处理文本，也就是字符串。一个字符串用于存储一系列的字符，通常 JS 字符串是原始值，可以使用变量声明，也可以使用 new 关键字将字符串定义为一个对象，在 JS 中并不提倡使用 new 关键字创建对象。原始值字符串是没有属性和方法的，但是可以使用 JS 的属性和方法，因为 JS 在执行属性和方法时可以把原始值视为对象。

　　可以使用 JS 内置的 length 属性来计算字符串的长度。比如：

var str = "abcdefghijklmnopqrstuvwxyz";
alert(str.length);    //返回：26
　　下面是一些字符串常用的方法：

　　(1)、charAt()
　　str.charAt(index)　　返回指定索引位置的字符，也就是获取字符串的某一位字符。

　　(2)、concat()
　　str1.concat(str2, str3, ...., strN)　　用于连接两个或多个字符串，返回连接后的字符串。

　　(3)、indexOf()
　　str.indexOf(某个字符, strat)　　返回字符串中某个字符从指定位置开始首次出现的位置，第二个参数可选，规定在字符串中开始查找的位置，他的合法值为 0 到字符串的长度 -1：str.length-1，如果不设置该参数，则从字符串的首字符开始查找。返回值为数值，如果找到则返回该字符首次出现的位置，没找到则返回 -1。

　　(4)、search()
　　search(str/RegExp)　　返回字符串中某个字符首次出现的位置，该参数为字符或者正则表达式，配合正则效果更好，返回值为数值，如果没有匹配到，则返回 -1。

　　**indexOf() 和 search() 区别：**
　　这两个方法都返回字符首次出现的位置，但是配合正则使用 search() 要比 indexOf() 更强大，如果是一个普通的字符串或者对一个具体的字符串来提取，那么使用 indexOf() 的效率更好，更省资源，但如果是查找特殊的字符串，比如有数字有字母，那么 indexOf() 就没办法执行了，必须要使用正则表达式和 search() 方法。

 

　　(5)、match()
　　match(str/RegExp)　　用于查找字符串中指定的字符，并且返回该字符，该方法配合正则使用效果更好，如果不使用正则表达式，则只是返回首次出现的指定字符，不会再向后匹配，如果配合正则并且全局匹配，则以数组形式返回字符串中所有指定的字符，如果没找到，则返回 null。

　　(6)、replace()
　　replace(str/RegExp, newstr)　　用于字符串中将一些字符替换成另一些字符，返回一个新字符串。该方法有两个参数，第一个参数规定需要被替换的字符，第二个参数为新字符，就是替换后要显示的字符。配合正则使用效果更好，可以替换所有匹配。最常见的应用就是：敏感词过滤。

　　(7)、lastIndexOf()
　　lastIndexOf() 和indexOf 相反，lastIndexOf(某个字符, strat)　　返回字符串中某个字符从指定位置开始最后出现的位置，在指定位置从后向前查找。第二个参数可选，他的合法值为0到字符串的长度 -1：str.length-1，如果不设置该参数，则从字符串的最后一个字符开始查找。返回值为数值，如果找到则返回该字符最后出现的位置，没找到则返回 -1。

　　(8)、slice()
　　slice(start, end)　　提取字符串的某个部分，并以新的字符串返回被提取的部分，不包括结束位置的字符。第一个参数为起始位置，第一个字符的位置为 0，第二个参数 end 可选，结束位置的下标，如果不设置该参数，则提取从起始位置开始到字符串最后一个字符的子字符串。提取字符的参数可以是负数，则规定的是从字符串的尾部位置开始算起，也就是说：-1 代表字符串最后一个字符，-2 指倒数第二个字符，依次类推。提取全部字符可写为：slice(0)，也可以不设置参数，直接使用。　

　　(9)、substr() 
　　substr(start, length)　　提取字符串从开始位置指定字符串长度的字符，并以新的字符串返回被提取的部分。该方法可以替代 substring() 和 slice() 来使用。第一个参数为起始位置，可以是负数，则从尾部开始算起。第二个参数为提取字符串的长度，该参数可选，且不能小于 1，否则返回一个空字符串，如果不设置该参数，则返回从起始位置开始到最后一个字符的子字符串。

　　(10)、substring()
　　substring(from, to)　　提取介于字符串指定的两个下标中间的字符，并以新的字符串返回被提取的部分，不包括结束位置的字符。第一个参数规定提取子串的第一个字符在字符串中的位置，简单说就是开始位置，该参数是一个非负的整数。第二个参数是要提取的子串最后一个字符在字符串中的位置，也就是结束位置，该参数可选，为一个非负的整数，如果不设置该参数，则返回从开始位置到最后一个字符的子字符串。如果第二个参数比第一个参数大，则在提取子串之前会将较小的数作为开始位置，较大的作为结束位置。

 

　　slice()、substr() 、substring()三者区别：
　　从定义上看，三者都为提取子字符串，slice() 和substring() 可以看成是同类，参数都是字符串的某个开始位置到结束位置，都不包括结束位置。而 substr() 则是提取从字符串的某个位置开始，指定字符串长度的子字符串。他们的共同点都是：第二个参数可选，如果不设置，都返回从开始位置到最后一个字符的子字符串。

　　从可设置的参数看，slice() 的两个参数都可为负数，表示从尾部开始算起。substr() 的第一个参数也可以设置为负数，而 substring() 的参数则不接受负数，如果设置为负数或者其他无效的数，则会被当作 0 处理。

　　(11)、split()
　　str.split()　　用于分割字符串，返回字符串数组。该方法有2个可选的参数，第一个参数为分割方式，可以是正则表达式，第二个参数设置返回字符串的最大长度。

```
 1 <script>
 2 var str = "Good good study day day up！";
 3 
 4 //忽略参数：
 5 var arr = str.split();
 6 document.write(arr);
 7 //返回：Good good study day day up！
 8 
 9 //分割每个字符包括空格：
10 var arr = str.split('');
11 document.write(arr);
12 //返回：G,o,o,d, ,g,o,o,d, ,s,t,u,d,y, ,d,a,y, ,d,a,y, ,u,p,！
13 
14 //使用空格作为分割符：
15 var arr = str.split(' ');
16 document.write(arr);
17 //返回：Good,good,study,day,day,up！
18 
19 //规定返回数组的最大长度
20 var arr = str.split(' ', 3);
21 document.write(arr);
22 //返回：Good,good,study
23 
24 //使用一个字符作为分割符：
25 var arr = str.split('d');
26 document.write(arr);
27 //返回：Goo, goo, stu,y ,ay ,ay up！
28 </script>
```

　　(12)、toString()

　　toString()　　方法用于将对象转换为字符串。

　　(13)、valueOf() 

　　valueOf()　　方法用于将对象转换为一个基本数据的值，返回对象的原始值。

　　(14)、toLowerCase()

　　str.toLowerCase()　　方法用于将字符串转换为小写。

　　(15)、toUpperCase()

　　str.toUpperCase()　　方法用于将字符串转换为大写。
 

### 2、Number 对象
　　JS 只有一种数字类型，可以是整数，也可以是小数。整数最大可以有 15 位，小数最大可以有17位，在 JS 中小数运算并不是非常精确，所以大多数情况下，需要将小数转换为整数。注意：整数的第一位不能为 0，否则会得到意想不到的结果。如下面的运算结果：

1 var sum = 0.1 + 0.2;
2 alert(sum);
3 //返回：0.30000000000000004
 

　　(1)、infinity 和 -infinity

　　当数字运算超过了 JS 所能表示的数字上限时，结果就为一个无穷大的值，在 JS 中用infinity表示。当负数运算超过了 JS 的负数范围，结果就为一个负无穷大的值，也叫无穷小，在 JS 中用 -infinity 表示。基于无穷大的加减乘数运算，他们的结果还是无穷大，并保留正负号。一个整数或者负数除以0，得到的都是无穷大。

　　(2)、NaN

　　NaN 表示非数字的特殊值，该属性用于指示一个值不是数字。返回值为布尔值。可以使用函数 isNaN() 判断一个值是否是 NaN 值。

```
 1 var x = 123;
 2 var y = 'abc';
 3 
 4 alert(isNaN(x));    //返回：false
 5 alert(isNaN(y));    //返回：ture
 6 
 7 alert(x == y);    //返回：false
 8 //NaN和NaN是不相等的。所以为假。
 9 
10 var a = 2/0；
11 alert(isNaN(a));    //返回：false
12 //无穷大是一个数字
```
 
　　Number 对象属性：

　　(1)、MAX_VALUE 和 MIN_VALUE

　　MAX_VALUE 表示最大的数，它的近似值为： 1.7976931348623157 x 10308。如果大于该数则表示无穷大。MIN_VALUE 表示最小的数，它的近似值为：5 x 10-324，MIN_VALUE 是最接近 0 的数，但不是负值。比该属性小的值用 0 表示。由于他们都是 Number 对象的静态属性，只能通过 Number 调用，所以使用自定义的 Number 将无法获取属性，返回值为 undefined。

```
 1 //JS最大数
 2 alert(Number.MAX_VALUE);
 3 //返回：1.7976931348623157e+308
 4 
 5 //JS最小数
 6 alert(Number.MIN_VALUE);
 7 //返回：5e-324
 8  
 9 //e为科学计数法：
10 var a = 123e5;
11 var b = 123e-5; 
12 
13 alert(a);    //返回：12300000
14 alert(b);    //返回：0.00123
```
 

　　(2)、POSITIVE_INFINITY 和 NEGATIVE_INFINITY

　　POSITIVE_INFINITY 属性代表无穷大，表示比 MAX_VALUE 大的数。NEGATIVE_INFINITY 属性表示负无穷大，表示比 MIN_VALUE 小的数。由于他们都是 Number 对象的静态属性，只能通过 Number 调用，所以使用自定义的 Number 将无法获取属性，返回值为 undefined。
```
1 alert(Number.POSITIVE_INFINITY);
2 //返回：Infinity
3 
4 alert(Number.NEGATIVE_INFINITY);
5 //返回：-Infinity
 ```

　　Number 对象方法：

　　(1)、toExponential() 

　　toExponential(n)　　可把对象的值转换成指数计数法。该方法有一个可选的参数，用于规定计数法中的小数位数，包括 0 和 20 之内的值，如果不设置该参数，将使用尽可能多的数字。

　　(2)、toFixed()

　　toFixed(n)　　可把数字转换为字符串，并四舍五入为指定小数点后位数的数字。该方法必须设置一个参数，规定小数的位数，包括 0 和 20 之内的值，如果不设置该参数，将默认为 0。

　　(3)、toPrecision()

　　toPrecision(n)　　可把数字格式化为指定的长度，如果超出指定的长度将转换为指数计数法。该方法必须设置一个参数，规定转换为指数计数法的最小位数，包括 1 和 21 之内的值，如果不设置该参数，则调用 toString() 方法，而不对数字转换。

　　(4)、toString()

　　toString()　　方法用于将对象转换为字符串。

　　(5)、valueOf() 

　　valueOf()　　方法用于将对象转换为一个基本数据的值，返回对象的原始值。

 
### 3、Math 对象
　　Math 对象的作用是：执行常见的算数任务。该对象无需在使用这个对象之前对它进行定义。

　　下面主要介绍 Math 对象的一些常用方法：

　　(1)、ceil() 

　　Math.ceil()　　可对一个数向上取整，如果参数是一个整数，该值不变。向上取整运算返回的是一个大于或等于该值并且与之最接近的整数。

```
 1 alert(Math.ceil(-0.1));    //返回：0
 2 
 3 alert(Math.ceil(-9.9));    //返回：-9
 4 
 5 alert(Math.ceil(2.1));     //返回：3
 6 
 7 alert(Math.ceil(2.9));     //返回：3
 8 
 9 var num = 8;
10 alert(Math.ceil(num));    //返回：8
```
 

　　(2)、floor() 

　　Math.floor()　　可对一个数进行向下取整，如果参数是一个整数，该值不变。向下取整运算返回一个小于或等于该值的最大整数。

```
 1 alert(Math.floor(-0.1));    //返回：-1
 2 
 3 alert(Math.floor(-9.9));    //返回：-10
 4 
 5 alert(Math.floor(2.1));     //返回：2
 6 
 7 alert(Math.floor(2.9));     //返回：2
 8 
 9 var num = 8;
10 alert(Math.floor(num));    //返回：8
```
 

　　(3)、round() 

　　Math.round()　　可把一个数字四舍五入为最接近的整数。

```
 1 alert(Math.round(-0.1));    //返回：0
 2 
 3 alert(Math.round(-9.9));    //返回：-10
 4 
 5 alert(Math.round(2.49));     //返回：2
 6 
 7 alert(Math.round(2.5));     //返回：3
 8 
 9 var num=8;
10 alert(Math.round(num));    //返回：8
```

　　(4)、random() 方法

　　Math.random()　　可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。

```
 1 //获得一个随机数：
 2 alert(Math.random());
 3 
 4 //获得 0~10 之间的随机数：
 5 alert(Math.random()*10);
 6 
 7 //random ()方法和round()方法配合，可获得一个不大于10的整数：
 8 alert(Math.round(Math.random()*10));
 9 
10 //随机数每次返回的值都不同。
```

### 4、Array 对象
　　数组对象的作用是：使用单个变量来存储一系列的值。

　　数组最常用的属性就是 length，用于返回数组中数据的长度，也可用于设置数组的长度。
```
1 var arr = [1,2,3,4,5,6];
2 arr.length=3;
3 alert(arr);    //返回1,2,3
4 
5 //arr.length=0;        可用于快速清空数组
 ```

　　下面主要介绍 Array 对象一些常用方法：

　　(1)、concat()
　　arr.concat(arr1, arr2, ..., arrN)　　用于连接两个或多个数组，该方法返回一个新数组，不改变原来数组。该方法的参数可以是具体的值，也可以是数组对象，可以是任意多个。如果该参数是具体的值，将把该值插入到原来的数组返回。

　　(2)、join()
　　join()　　用于将数组中的所有元素转换成一个字符串，元素是通过指定的分隔符分隔的。该方法有一个可选参数，用于指定分隔方式。如果不设置该参数，默认使用逗号分割。

```
 1 var arr1 = [86,'010']
 2 var arr2 = [15278654321]
 3 var arr3 = arr1.concat(arr2);
 4 
 5 document.write(arr3.join());
 6 //返回：86,010,15278654321
 7 
 8 document.write(arr3.join("."));
 9 //返回：86.010.15278654321
10 
11 document.write(arr3.join("-"));
12 //返回：86-010-15278654321
13 
14 document.write(arr3.join("|"));
15 //返回：86|010|15278654321
 ```

　　(3)、reverse()
　　arr.reverse()　　用于颠倒数组中元素的顺序。
```
1 var arr = ['Banana', 'Orange', 'Apple'];
2 document.write(arr);
3 //返回：Banana, Orange, Apple
4 
5 document.write(arr.reverse());
6 //返回：Apple,Orange,Banana
 ```

　　(4)、slice()
　　arr.slice(start, end)　　可从已有的数组中返回选定的元素。该方法也适用于提取子字符串。也不包括开始位置和结束位置的元素。第一个参数规定从何处开始选取，第二个参数可选，规定从何处结束选取，如果省略该参数，则返回从开始位置到数组尾部的所有元素。如果参数为负数，则从数组最后一个元素开始算起。

　　(5)、sort()
　　arr.sort(方法函数)　　用于对数组的元素排序。排序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。使用数字排序，你必须通过一个函数作为参数来调用。函数指定数字是按照升序还是降序排列。如果数字排序不指定方法函数，默认是按照字母升序，则 100 会排在 15 前边。

```
 1 var arr = [99,15,21,2,8,56,100,1];
 2 
 3 //默认排序：
 4 document.write(arr.sort());
 5 //返回：1,100,15,2,21,56,8,99
 6 
 7 //指定方法函数，按升序排序。
 8 function ascNum(a,b) {
 9     return a-b;
10 }
11 document.write(arr.sort(ascNum));
12 //返回：1,2,8,15,21,56,99,100
13 
14 //指定方法函数，按降序排序。
15 function desNum(a,b) {
16     return b-a;
17 }
18 document.write(arr.sort(desNum));
19 //返回：100,99,56,21,15,8,2,1
 ```

　　(6)、shift() 
　　arr.shift()　　删除数组的第一个元素。 此方法将改变数组的长度。

```
1 var arr = ['Banana', 'Orange', 'Apple'];
2 document.write(arr.length);    //返回：3
3 
4 arr.shift();
5 document.write(arr);    //返回：Orange,Apple
6 
7 document.write(arr.length);     //返回：2
```

　　(7)、pop()
　　arr.pop()　　删除数组的最后一个元素。此方法将改变数组的长度。

```
1 var arr = ['Banana', 'Orange', 'Apple'];
2 document.write(arr.length);    //返回：3
3 
4 arr.pop();
5 document.write(arr);    //返回：Banana,Orange
6 
7 document.write(arr.length);     //返回：2
```

　　(8)、unshift()
　　arr.unshift()　　向数组开头添加一个或多个元素。此方法将改变数组的长度。

```
1 var arr = ['Banana', 'Orange', 'Apple'];
2 document.write(arr.length);    //返回：3
3 
4 arr.unshift('Mango', 'Pear');
5 document.write(arr);
6 //返回：Mango,Pear,Banana,Orange,Apple
7 
8 document.write(arr.length);    //返回：5
```
 

　　(9)、push()
　　arr.push()　　向数组末尾添加一个或多个元素。此方法将该变数组的长度。

```
1 var arr= ['Banana', 'Orange', 'Apple'];
2 document.write(arr.length);    //返回：3
3 
4 arr.push('Mango', 'Pear','Lemon');
5 document.write(arr);
6 //返回：Banana,Orange,Apple,Mango,Pear,Lemon
7 
8 document.write(arr.length);    //返回：6    
```

　　(10)、splice()
　　arr.splice(start, length, arrElement1, ..., arrElementN)　　用于删除、插入或替换数组的元素。该方法会改变数组的原始数据。该方法有多个参数，前两个为必须的参数。第一个参数规定从何处开始删除或插入。第二个参数规定删除元素的长度，如果设置为 0，则不删除元素，如果不定义该参数，则删除从 start 规定的位置开始到原数组结尾的所有元素。最后的参数可选，要添加到数组的新元素。

```
 1 var arr = [1,2,3,4,5,6];
 2 
 3 //删除元素的应用：
 4 //从第2个位置开始，删除长度为3。
 5 arr.splice(2,3);
 6 document.write(arr+'<br>');
 7 //返回：1,2,6
 8 
 9 //插入元素的应用：
10 //从第2个位置开始，删除为0个元素，也就是不删除，插入abc。
11 arr.splice(2,0,'a','b','c');
12 document.write(arr+'<br>');
13 //返回：1,2,a,b,c,3,4,5,6
14 
15 //替换元素的应用：
16 //从第2个位置开始，删除3个元素，再插入def。
17 arr.splice(2,3,'d','e','f');
18 document.write(arr);
19 //返回：1,2,d,e,f,6
```
 

　　(11)、toString() 
　　toString()　　方法可把数组转换为字符串，并返回结果。

　　(12)、valueOf() 
　　valueOf()　　方法返回数组对象的原始值。
 

### 5、Date 对象

　　Date 对象用于处理日期和时间。可以通过 new 关键词来定义 Date 对象。

　　下面例子是获取当前的所有日期：

```
 1 var d = new Date();
 2 //获取当前日期
 3 document.write(d);
 4  
 5 //获取当前的年份
 6 document.write(d.getFullYear() + '年');
 7 
 8 //获取当前月份，月份从0开始计算，所以需要+1
 9 document.write(d.getMonth() + 1 + '月');
10 
11 //获取当前是当月中的哪一天
12 document.write(d.getDate() + '日');
13 
14 //获取当前时间的小时
15 document.write(d.getHours() + '时');
16 
17 //获取当前时间的分钟
18 document.write(d.getMinutes() + '分');
19 
20 //获取当前时的秒数
21 document.write(d.getSeconds() + '秒');
22 
23 //获取当前的毫秒数t
24 document.write(d.getMilliseconds() + '毫秒');
25 
26 //获取星期
27 document.write('星期' + d.getDay());
28 
29 //星期从0开始算起，从星期天开始计算。
30 //getDay()返回的是0-6的数字，0表示星期天。如果要返回相对应的“星期”，需要通过数组完成。
31 var weekday = ["星期日","星期一","星期二","星期三","星期四","星期五","星期六"];
32 var week = d.getDay();
33 document.write(weekday[week]);
```

　　下面例子用于设置日期：

```
 1 var d = new Date();
 2 
 3 //设置年份
 4 d.setFullYear(2020);
 5 document.write(d);
 6 
 7 //该方法也可用于设置月份(介于0-11之间)和天数(介于1-31之间)。
 8 //月份：-1为去年的最后一月，-2为去年的倒数第二个月。
 9 //12为明年的第一个月，13为明年的第二个月。
10 //天数：0为上个月最后一天，-1为上个月最后一天之前的天数。
11 //如果当月有31天，32为下个月第一天，如果当天只有30天，32则为下个月的第二天
12 d.setFullYear(2020, 11, -1);
13 document.write(d);
14 //设置月份(介于0-11之间)，也可用于设置天数
15 d.setMonth(5);
16 document.write(d);
17 
18 
19 //设置天数(介于1-31之间)
20 d.setDate(12);
21 document.write(d);
22 
23 //设置小时
24 //值介于0(午夜)-23(晚上11点)之间，-1为昨天的最后一个小时，24为明天的第一个小时
25 d.setHours(24);
26 document.write(d);
27 
28 //该方法也可用于设置分钟、秒以及毫秒数。
29 //分钟：介于0-59之间，-1为上一小时最后一分钟，60为下一个小时第一分钟
30 //秒：介于0-59之间，-1为上一分钟最后一秒，60为下一分钟第一秒
31 //毫秒：介于0-999之间，-1为上一秒钟的最后一毫秒，1000为下一秒钟的第一毫秒
32 d.setHours(21,30,1);
33 document.write(d);
34 
35 //获取小时 一个小应用：返回24小时之前的的时间
36 var d = new Date();
37 d.setHours(d.getHours()-24);
38 document.write(d);
39 
40 //设置分钟，也可用于设置秒数和毫秒数
41 d.setMinutes(20);
42 document.write(d);
43 
44 //设置秒，也可用于设置毫秒
45 d.setSeconds(10);
46 document.write(d);
47 
48 //设置毫秒
49 d.setMilliseconds(999);
50 document.write(d);
```
 

　　getTime() 和 setTime()
```
 1 var d = new Date();
 2 
 3 //获取1970年元旦距今的毫秒数
 4 document.write(d.getTime()+'毫秒');
 5 
 6 //向1970年元旦增加1325347200000毫秒，返回新日期
 7 d.setTime(1325347200000);
 8 document.write(d);
 9 
10 //获取指定时间据1970年之间的毫秒数
11 var d = Date.parse("2012, 12, 12");
12 document.write(d+'毫秒');
13 
14 //计算1970年元旦至今有多少年：
15 var minutes = 1000*60;
16 var hours = minutes*60;
17 var day = hours*24;
18 var year = day*365;
19 var d = new Date();
20 var t = d.getTime();
21 var y = Math.round(t/year);
22 document.write(y + '年');
```
 

　　日期转换：
```
 1 var d = new Date();
 2 //当前时间
 3 document.write(d);
 4 
 5 //将日期部分(不包括时分秒)转换为字符串
 6 document.write(d.toDateString());
 7 
 8 //将日期部分(不包括年月日)转换为字符串
 9 document.write(d.toTimeString());
10 
11 //根据本地时间将日期转换为字符串
12 document.write(d.toLocaleString());
13 
14 //根据本地时间将日期部分(不包括时分秒)转换为字符串
15 document.write(d.toLocaleDateString());
16 
17 //根据本地时间将日期部分(不包括年月日)转换为字符串
18 document.write(d.toLocaleTimeString());
19 
20 //使用ISO标准将日期转换为字符串
21 //该标准格式为：YYYY-MM-DDTHH:mm:ss.sssZ
22 document.write(d.toISOString());
23 
24 //将日期转换为JSON格式
25 //JSON格式与ISO标准是同样的格式
26 document.write(d.toJSON());
```

　　toString()　　方法可把日期对象转换为字符串，当日期需要显示为一个字符串时，该方法会被自动调用。
　　valueOf()　　方法返回日期对象的原始值。该方法将返回1970年元旦至今的毫秒数。

### 6、数据类型转换
　　JS 中有5种不同的数据类型：string、number、boolean、object、function。

　　3 种对象类型：Object、Date、Array。2 个不包含任何值的类型：ubll、undefined。

　　可以使用 typeof 操作符来查看 JS 变量的数据类型。

```
 1 var str = '小明';
 2 alert(typeof str);    //返回：string
 3 
 4 var num = 12;
 5 alert(typeof num);    //返回：number
 6 
 7 var num1 = NaN;
 8 alert(typeof num1);    //返回：number
 9 
10 var fun = function (){alert('abcd');};
11 alert(typeof fun);    //返回：function
12 
13 var boo = true;
14 alert(typeof boo);    //返回：boolean
15 
16 var obj = document;
17 alert(typeof obj);    //返回：object
18 
19 var arr = [1,2,3,4];
20 alert(typeof arr);    //返回：object
21 
22 var d = new Date();
23 alert(typeof d);    //返回：object
24 
25 var json = {a:'12', b:21};
26 alert(typeof json);    //返回：object
27 
28 var n = null;
29 alert(typeof n);    //返回：object
30 
31 var x;
32 alert(typeof x);        //返回：undefined
33 alert(typeof y);        //返回：undefined
34 //未定义有2种情况：
35 //1、真的没有定义（如y）
36 //2、虽然定义了，但是没有给赋值（如x)
```
 
　　数组对象和日期对象无法通过 typeof 来判断数据类型，因为都返回 object。可以使用 constructor 属性来查看。constructor 属性返回一个对象的构造函数，将返回的构造函数转换为字符串，再判断是否包含数组和日期。

```
 1 //返回数组和日期的构造函数：
 2 var arr = ["abc", "123", "123abc", "abc123"];
 3 alert(arr.constructor);
 4 //返回：function Array() { [native code] }
 5 
 6 var d = new Date;
 7 alert(d.constructor);
 8 //返回：function Date() { [native code] }
 9 
10 
11 var arr = ["abc", "123", "123abc", "abc123"];
12 function con(obj) {
13     return arr.constructor.toString().indexOf("Array") > -1;
14 }
15 alert(con(arr));    //返回：ture
16 
17 var d = new Date();
18 function cons(obj) {
19     return d.constructor.toString().indexOf("Date") > -1;
20 }
21 alert(cons(d));    //返回：ture
```
 　
　　强制类型转换，也叫显式类型转换。

　　(1)、转换为字符串：

　　全局方法 string() 和 toString() 方法可用于将一个值转换为字符串。string() 可用于任何类型的数字、字母、变量、表达式。

　　二者区别：

　　大多数值都有 toString() 方法，除了 null 和 undefined。字符串本身也可以使用 toString() 方法，将返回字符串的原始值。

　　任何值都可以使用 string() 方法，如果该值有 toString() 方法，则使用该方法，如果该值没有 toString() 方法，那就为 null 和 undefined，则返回 null 和 undefined。

```
 1 var str = '小明';
 2 alert(String(str));
 3 alert(str.toString());
 4 //都返回：小明
 5 
 6 var num = 123;
 7 alert(String(num));
 8 alert(num.toString());
 9 //都返回：123
10 
11 var and = 123+100;
12 alert(String(and));
13 alert(and.toString());
14 //都返回：223
```
 
　　(2)、转换为数字：
　　全局方法 Number() 可以将字符串转换为数字。空字符串转换为 0，特殊值字符串将转换为 NaN。

```
1 var str = '123';
2 alert(Number(str));    //返回：123
3 
4 var str = '';
5 alert(Number(str));    //返回：0
6 
7 var str = '200px';
8 alert(Number(str));    //返回：NaN
```

　　最常用的就是转换为整数和小数。parseInt() 方法用于转换整数。parseFloat() 方法用于转换小数。

```
 1 var a = '3.1'
 2 alert(parseInt(a));    //返回：3
 3 var a = '3.9'
 4 alert(parseInt(a));    //返回：3
 5 var a = '12px34';
 6 alert(parseInt(a));    //返回：12
 7 var a = 'px1234';
 8 alert(parseInt(a));    //返回：NaN
 9 
10 var d = '3.14';
11 alert(parseFloat(d));    //返回：3.14
12 var d = '3.99';
13 alert(parseFloat(d));    //返回：3.99
```
 
　　+ 运算符可以连接字符串，也可以将字符串转换为数字。

```
1 var n = '12ab';
2 var x = '34';
3 alert(n+x);    //返回：12ab34
4 alert(parseInt(n)+x);    //返回：1234
5 
6 var y = + x;
7 alert(typeof x);    //返回：string
8 //若变量不能转换，但仍然是一个数字，NaN
9 alert(typeof y);    //返回：number
```
 
　　NaN 的数据类型是 number，NaN 表示非数字(Not a Number)，所以本身也为数字。

```
 1 var a = parseInt('abc');
 2 var b = parseInt('12edf');
 3 var c = 12+NaN;
 4 alert(c);    //返回NaN
 5 
 6 //判断NaN是否等于NaN
 7 alert(a==b);    //返回false
 8 
 9 //isNaN判断一个变量是不是NaN
10 alert(isNaN(a));    //返回：true
11 alert(isNaN(b));    //返回：flase
```

　　利用这一特性，可以做一个简易的文本框求和，用户输入的文本框的值为字符串，需要将字符串转换为数字，再判断输入的值是否为数字。

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>文本框求和</title>
 6 </head>
 7 <script>
 8 window.onload = function (){
 9     var x = document.getElementById('txt1');
10     var y = document.getElementById('txt2');
11     var oBth = document.getElementById('but1');
12     oBth.onclick = function (){
13         //将输入的值转换为整数：
14         var n1 = parseInt(x.value);
15         var n2 = parseInt(y.value);
16             //判断用户输入的n1是不是非数字
17             if(isNaN(n1)){
18                 alert('输入的第一个数字有误');
19             }
20             else if(isNaN(n2)){
21                 alert('输入的第二个数字有误');
22             }
23             //若都输入的为数字，则求和
24             else{
25                 alert(n1+n2);
26             }
27     };
28 };
29 </script>
30 <body>
31 <input id="txt1" type="text" >
32 <input id="txt2" type="text" >
33 <input id="but1" type="button" value="求和">
34 </body>
35 </html>    
```
 

　　全局方法 Number() 可将布尔值转换为数字。
```
1 alert(Number(false));    //返回 0
2 alert(Number(true));    // 返回 1
 ```

　　隐式类型转换，也叫自动转换类型。

　　当 JS 尝试操作一个“错误”的数据类型时，会自动转换为“正确”的类型再去执行，这就是隐式类型转换。直接看几个例子：

```
 1 var a = 2;
 2 var b = '2';
 3 //比较数字2和字符串2是否相等
 4 alert(a==b);    //返回：true
 5 //why? 相等比较实际上比较前是先将a和b转换为同一类型，再进行比较的。
 6 
 7 //比较数字2和字符串2是否全等
 8 alert(a===b);    //返回：返回false
 9 //why? 全等比较不转换类型，直接比较。a为数字，b为字符串。
10 //所以，一般情况下，采用全等比较，更为严谨。
11 
12 var c = '12';
13 var d = '5';
14 //两个值为数字的字符串做+运算
15 alert(c+d);    //返回125
16 //why? "+"运算符有2种功能：1、字符串连接。2、算术运算(数字相加)。系统会采用最直接的方法。
17 
18 //两个值为数字的字符串做-运算
19 alert(c-d);　　//返回7
20 //why? 在做减法运算时会先转换为同类型，再做运算。"-"运算符只有1种功能。算术运算(数字相减)。
 ```

## JS深入
### 1、JS流程控制语句
　　(1)、if 判断
　　if 语句是基于条件成立时才执行相应的代码。

　　if...else　　语句是在指定的条件成立时执行if后的代码，在条件不成立时执行else后的代码。

　　if...else　　嵌套语句是在多种条件下选择相应的代码快之一来执行。

　　if 语句适用于任意类型的数据，可处理复杂的逻辑关系。

　　(2)、switch语句
　　当有很多种选择的时候，switch 比 if...else 使用更方便，结构简洁，专为多重选择设计，但是仅能处理多个枚举型逻辑关系。该语句使用 if 也可以完成，这个看个人喜好。

　　switch 语句的工作原理：首先创建一个表达式，通常为变量，之后表达式的值与 switch 语句中每个 case 的值做比较，如果匹配，则执行该 case 后的语句，若与所有 case 值都不匹配，则执行 default 后的语句。在使用 switch 语句时，每个 case 语句后必须使用 break 跳出循环，阻止运行下一个 case。

```
 1 var d = new Date().getDay();
 2 //如果今天不是周末，则提示默认消息
 3 switch (d){
 4     case 6:
 5         alert("今天是星期六");
 6         break;
 7     case 0:
 8         alert("今天是星期天");
 9         break;
10     default:
11         alert("同志尚未努力，革命仍需成功。");
12 }
```

　　switch 语句在做比较时，使用的是全等，而不是相等，所以在字符串与数字匹配时，需要特别注意。

```
 1 //使用switch语句将字符串与数字做比较
 2 //返回：不等于，执行default语句
 3 var n = '5';
 4 switch(n){
 5     case 5:
 6         alert('等于，执行case语句');
 7         break;
 8     default:
 9         alert('不等于，执行default语句');
10 }
11 
12 //使用if语句将字符串与数字做比较
13 //返回：等于
14 var n = '2';
15 if(n == 2){
16     alert('等于');
17 }else{
18     alert('不等于');
19 }
20 
21 //将case的值改为字符串再做比较
22 //返回：等于，执行case语句
23 var n = '2';
24 switch(n){
25     case '2':
26         alert('等于，执行case语句');
27         break;
28     default:
29         alert('不等于，执行default语句');
30 }
31 
32 
33 //使用全等再做比较
34 //返回：不等于
35 var n = '2';
36 if(n===2){
37     alert('等于');
38 }else{
39     alert('不等于');
40 }
```

　　(3)、for 循环

　　很多事情不只是做一次，需要重复做。比如打印 10 份文件，每次打印 1 份，重复这个动作，直到打印完成。这样的事情就用 for 循环来完成，循环就是重复执行一段代码，每次的值不同。

　　下面是一个 for 循环的小应用，假设有 1.2.3. ... 10 不同面值的 RMB，计算一共有多少 RMB。
```
1 var sum = 0;
2 for(var rmb=1; rmb<=10; rmb++){ 
3     sum += rmb;
4 }
5 alert('一共有: ' + sum + '元');    //返回：一共有：55元
```

　　(4)、while 循环

　　while 循环和 for 循环具有相同的功能，只要指定条件为 ture，循环就可以一直执行，直到条件不再满足。

```
1 //使用while循环输出5个数字
2 var i = 0;    　　//第一部分：初始化，给一个初始的值，让i从0循环
3 while(i < 5){    //第二部分：条件。成立继续循环，不成立退出
4     alert(i);    //第三部分：语句
5     i++;　　　　　//第四部分：自增
6 }
7 //while循环使用比较复杂，使用for循环更简洁。
8 //for(初始化;条件;自增){语句}
```

　　(5)、do...while 循环

　　do...while 循环与 while 循环的原理结构是基本相同的，但是该循环会在检查条件是否为 ture 之前执行一次代码块，如果条件为 ture，则重复循环。该循环有一点小问题，因为他是先执行代码，后判断条件，如果条件不当，则进入死循环，导致浏览器崩溃。

```
 1 /*
 2 语法：
 3 do{
 4   执行语句
 5 }
 6 while(条件);
 7 */
 8 
 9 //操作有风险，尝试需谨慎
10 //若将循环条件改为：num <= 6 会导致浏览器崩溃  
11 var num = 6;
12 do{
13     document.write("数字:" + num + "<br>");
14     num -= 1;
15 }
16 while(num > 0);
```

　　(6)、JS 错误处理语句

　　try...catch 语句用于进行异常处理。try 语句用于检测代码块的错误，指明需要处理的代码段，catch 语句用于处理 try 语句中抛出的错误。try 语句首先被执行，如果运行中发生了错误，try 语句中的代码将被跳过执行 catch 中的语句。如果没有发生错误，则不执行 catch 中的语句。一般针对可预见性的错误，可使用 try...catch 语句进行处理。

```
 1 try{
 2     document.write("开始执行try语句" + '<br>');
 3     document.write("还没抛出错误" + '<br>');
 4     alert(x);        //抛出错误
 5     alert('123');    //没被执行
 6 }
 7 catch(e){
 8     document.write("捕捉到错误，开始执行catch语句" + '<br>');
 9     document.write("错误类型: " + e.name + '<br>');
10     document.write("错误信息: " + e.message);
11     alert('x');
12 }
```

　　throw 语句可用于创建自定义错误。官方术语为：创建或抛出异常(exception)。语法：throw '异常对象'。　　

　　throw 语句可以配合 try...catch 语句一起使用，以达到控制程序流，生成精确的错误消息。

```
 1 //输入0到10之间的数字，如果输入错误，会抛出一个错误，catch会捕捉到错误，并显示自定义的错误消息。
 2 <body>
 3 <input id="txt" type="text"/>
 4 <span id="demo" style="font-weight:bold;"></span><br>
 5 <input type="button" value="检测输入" onclick="error()">
 6 <script>
 7 function error(){
 8     try{
 9         var x = document.getElementById("txt").value;
10         var y = document.getElementById("demo");
11         y.style.color = 'red';
12         if(x == '') throw '输入不能为空';
13         if(isNaN(x)) throw '请输入数字';
14         var num = [7,8,9];
15         for(var i=0; i<num.length; i++){
16             if(x == num[i]){
17                 throw '该数字已经存在';
18             }
19         }
20         if(x == 0){
21             throw '输入不能为0';
22         }
23         else if(x > 10){
24             throw '数字太大了';
25         }
26         else if(x <= 3){
27             throw '数字太小了';
28         }
29         else{
30             y.style.color = 'green';
31             y.innerHTML = 'OK';
32         }
33     }
34     catch(e){
35         y.innerHTML = '错误提示：' + e + '！';
36     }
37 }
38 </script>
39 </body>
```
 
　　(7)、跳出循环

　　break 语句用于跳出当前循环，直接退出循环执行后面的代码，即终止整个循环，不再进行判断。continue 语句仅仅是跳出本次循环，继续执行后面的循环，即结束本次循环，接着去判断是否执行下次循环。return 可以终止函数体的运行，并返回一个值。

```
1 for(var i=0; i<6; i++){
2     if(i == 3) break;    //当i=3时跳出整个循环，不再执行循环
3     alert(i);    //返回：0,1,2
4 }
5 
6 for(var i=0; i<6; i++){
7     if(i == 3) continue;    //当i=3时跳出本次循环，继续执行后面循环
8     alert(i);    返回：0,1,2,4,5
9 }
```

### 2、JSON
　　JSON(JavaScript Object Notation)：JS 对象表示法。JSON 主要用于存储和交换数据信息，类似于 XML，但是相比 XML，JSON 易于阅读和编写，也易于解析。

 　　JSON 语法是 JS 对象表示语法的子集：数据在键值对中，并由逗号分隔，花括号保存对象，方括号保存数组。

　　JSON 语法的书写格式："名称" : "值", "名称" : "值"

　　名称和值包含在双引号中，并用冒号分隔，每条数据用逗号分隔。这很容易理解，相对于 JS 中 名称 = "值"。

　　JSON 的值可以是：数字(包括整数和小数)，字符串(包含在双引号中)，布尔值(true 或 false)，对象(包含在花括号中)，数组(包含在方括号中)，或者为 null。

　　JSON 是纯文本，通常用于服务端向网页传递数据，从服务器上获取 JSON 数据，然后在网页中使用该数据。

　　(1)、JSON对象

```
1 var json = {"a": 12, "b": "abc", "c":[1,2,3]};
2 //返回第一项的值：
3 alert(json.a);
4 
5 //修改第二项的值
6 alert(json.b = "xyz");
7 
8 //返回第三项数组中第一项的值
9 alert(json.c[0]);
```

　　(2)、JSON 和数组

　　相同点：

　　都可以通过下标返回某项的值。都可以使用循环。虽然 JSON 没有 length 属性，不能使用 for 循环，但是可以使用 for...in 循环，完成与 for 循环相同的动作。

　　数组也可以使用 for...in 循环，但最好还是使用 for 循环。for...in 循环遍历的是对象的属性，而不是数组元素。

　　不同点：

　　JSON 的下标是字符串，数组的下标为数字。JSON 没有 length 属性，数组有该属性。

```
 1 var arr = [12,5,7];
 2 var json = {"a":12,"b":5,"c":7};
 3 
 4 alert(arr[0]);    　　//返回：12
 5 alert(json["a"]);    //返回：12
 6 
 7 alert(arr.length);　　　　//返回：3
 8 alert(json.length);　　　//返回：undefined
 9 
10 //数组for循环
11 for(var i=0; i<arr.length; i++){
12     alert('第' + (i+1) + '个数据是：' + arr[i]);
13 }
14 alert(typeof i);    //返回：number
15 
16 //数组使用for...in循环
17 for(var i in arr){
18     alert('第' + (i+1) + '个数据是：' + arr[i]);
19 }
20 alert(typeof i);    //返回：string
21 
22 //JSON使用for...in循环
23 for(var i in json){
24     alert('第' + i + '个数据是：' + json[i]);
25 }
```

　　(3)、JSON 数组对象

```
 1 <body>
 2 <p>
 3 姓　名: <span id="fname"></span><br> 
 4 性　别: <span id="gender"></span><br>
 5 员工号: <span id="num"></span><br> 
 6 修改姓名: <span id="lname"></span><br> 
 7 </p> 
 8 <script>
 9 var staff = [
10     {"name" : "小明", "sex" : "男", "id" : 1}, 
11     {"name" : "小白", "sex" : "男", "id" : 2}, 
12     {"name" : "小红", "sex" : "女", "id" : 3}
13 ];
14 var x = document.getElementById("fname");
15 var y = document.getElementById("gender");
16 var z = document.getElementById("num");
17 var n = document.getElementById("lname");
18 //访问对象数组中第一项的值：
19 x.innerHTML = staff[0].name;
20 y.innerHTML = staff[0].sex;
21 z.innerHTML = staff[0].id;
22 
23 //修改数据：
24 n.innerHTML = staff[1].name = '大白';
25 </script>
26 </body>
``` 

 　　(4)、JSON 字符串对象

```
var str = '{"name":"小明", "sex":"男", "age":21}';
var toObj = JSON.parse(str);　　//JSON字符串转换为JSON对象
alert(toObj.name);
alert(typeof toObj);    //返回：object

var json = {"name":"小红", "sex":"女", "age":18};
var toStr = JSON.stringify(json);　　//JSON对象转换为JSON字符串
alert(toStr);    //返回字符串
alert(json.age);
alert(typeof toStr);    //返回：string
```

　　(5)、JSON 应用

　　当需要表示一组数据时，JSON 不但能够提高可读性，而且还可以减少复杂性。JSON 能够表示多个值，每个值又可包含多个值，例如要表示一个用户列表信息，就可以将所有信息存储在一个变量中，分成多项，每项中又可分成多个条目，每个条目中记录一个用户的信息。

```
 1 var userName = {
 2     "first": [{
 3         "name": "路飞",
 4         "sex": "男",
 5         "tel": "aaa"
 6     }, {
 7         "name": "索罗",
 8         "sex": "男",
 9         "tel": "bbb"
10     }, {
11         "name": "娜美",
12         "sex": "女",
13         "tel": "ccc"
14     }],
15 
16     "second": [{
17         "name": "卡卡西",
18         "sex": "男",
19         "tel": "ddd"
20     }, {
21         "name": "鸣人",
22         "sex": "男",
23         "tel": "fff"
24     }, {
25         "name": "佐助",
26         "sex": "男",
27         "tel": "eee"
28     }, {
29         "name": "皱田",
30         "sex": "女",
31         "tel": "sss"
32     }],
33 
34     "third": [{
35         "name": "小明",
36         "sex": "男",
37         "tel": "xxx"
38     },{
39         "name": "小红",
40         "sex": "女",
41         "tel": "zzz"
42     }]
43 };
44 
45 //获取用户的信息：
46 alert(userName.first[1].name + ' \n ' + userName.first[1].sex + '\n '+ userName.first[1].tel);
47 alert(userName.second[3].name + ' \n ' + userName.second[3].sex +' \n '+ userName.second[3].tel);
48 alert(userName.third[0].name + ' \n ' + userName.third[0].sex + ' \n '+ userName.third[0].tel);
```

　　说到 JSON，就不得不提一下 JSONP。JSONP (JSON with Padding) 是 JSON 的一种 "使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。可用于解决主流浏览器的跨域数据访问的问题。为什么从不同的域（网站）访问数据需要一个特殊的技术 (JSONP) 呢？这是因为同源策略。同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。由于该策略，一般来说位于 server1 的 demo.com 的网页无法与不是 server1 的 demo.com 的网页的服务器沟通，而 HTML 的 ```<script>``` 元素是一个例外。利用 ```<script>``` 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。


### 3、JS 定时器
　　定时器可以在指定的时间间隔之后再执行代码，而不是在函数被调用后立即执行。定时器在网页中应用非常广泛，最常见的就是动态时钟，还有比如购物网站的倒计时抢购。定时器的类型可分为两类：一类是间隔型，即 setInterval，在执行时，从页面加载后每隔一段时间执行一次，可无限执行。另一类是延迟型，即 setTimeout，在页面加载后延迟指定的时间，去执行一次，而且仅仅只执行一次。该方法属于 window 对象的两个方法。

　　(1)、setInterval

　　setInterval(function, time)　　方法可间隔指定的毫秒数，不停的执行指定的代码。该方法有两个参数，第一个参数是函数，指定定时器要调用的函数或要执行的代码串，第二个参数是时间，用毫秒计，1000 毫秒是 1 秒，指定执行的间隔时间。

　　(2)、setTimeout

　　setTimeout(function, time)　　方法可延迟指定的毫秒数后，再执行一次指定的代码。该方法也有两个参数，第一个参数为函数，指定要调用的函数或代码串，第二个参数指定在执行代码前需要等待多少毫秒。

```
1 function show(){
2     alert(1);
3 }
4 //当页面加载后，每隔1秒弹出一个1，无限次执行
5 setInterval(show,1000);
6 
7 //当页面加载后，在1秒后弹出一个1，只执行一次
8 setTimeout(show,1000);
```

　　setInterval 动态时钟效果：

```
 1 //动态显示时钟
 2 <p id="demo"></p>
 3 <script>
 4 function clock(){
 5     var d = new Date();   
 6     var time = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds() ;
 7     var oP = document.getElementById("demo").innerHTML = time;
 8 }
 9 setInterval(clock,1000);
10 </script>
```

　　setTimeout 统计效果：

```
 1 //setTimeout可实现统计：
 2 <input type="text" id="demo" >
 3 <script>
 4 var num = 0;
 5 function start() {
 6     document.getElementById('demo').value = num;
 7     num += 1;
 8     setTimeout(start,1000);
 9 }
10 setTimeout(start,1000);
11 </script>
```

　　可以开启定时器，也就可以关闭定时器。两种类型对应着两种方法。

　　(1)、clearInterval

　　clearInterval()　　方法可关闭由 setInterval() 方法执行的函数代码。使用该方法关闭定时器时，在创建间隔定时器时必须使用全局变量。

　　开始、停止动态时钟效果：

```
 1 //开始、停止动态时钟
 2 <input type="text" id="txt1" >
 3 <input type="button" value="停止" onclick="stop()" >
 4 <input type="button" value="开始" onclick="start()" >
 5 <script>
 6 var time = null;
 7 function start(){
 8     time = setInterval(function (){
 9         var d = new Date();   
10         var t = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds();
11         var oTxT = document.getElementById("txt1").value = t;
12     },1000);
13 };
14 start();
15 function stop(){
16     clearInterval(time);
17 }
18 </script>
```

　　(2)、clearTimeout

　　clearTimeout()　　方法用于停止执行由 setTimeout() 方法执行的函数代码。使用该方法时关闭定时器时，在创建延迟定时器时必须使用全局变量。

　　开始、停止统计效果：

```
 1 //开始、停止统计：
 2 <input type="text" id="txt1" >
 3 <input type="button" value="停止" onclick="stop()" >
 4 <input type="button" value="开始" onclick="start()" >
 5 <script>
 6 var num = 0;
 7 var time = null;
 8 function start(){
 9     var oTxt = document.getElementById('txt1').value = num;
10     num += 1;
11     time = setTimeout('start()',1000);
12 }
13 start();
14 function stop(){
15     clearTimeout(time);
16 }
17 </script>
```
 

### 4、Event 对象
　　event 对象代表事件的状态，用于获取事件的详细信息，如鼠标按钮、鼠标位置、键盘按键。事件通常与函数一起使用，函数不会在事件发生前被执行。

　　(1)、获取鼠标坐标

　　screenX 和 screenY 返回鼠标相对于屏幕的水平坐标和垂直坐标。参照点为屏幕的左上角。

　　clientX 和 clientY 返回鼠标相对于当前窗口可视区的水平坐标和垂直坐标。参照点为浏览器页面的左上角。
```
1 document.onclick = function (){
2     //可视区坐标
3     alert(event.clientX + ',' + event.clientY);
4     //屏幕坐标
5     alert(event.screenX + ',' + event.screenY);
6 }
```

　　(2)、获取鼠标钮按

　　button 事件属性用于获取鼠标哪个按钮被点击了。返回一个整数，0 代表左键，1 代表中键，2 代表右键。
```
1 //鼠标左右按键
2 document.onmousedown = function (){
3     alert(event.button);
4 }
``` 

　　(3)、获取键盘按键

　　keyCode 事件属性用于获取按下了键盘的哪个键，返回键码，表示键盘上真实键的数字。
```
1 //键盘按键
2 document.onkeydown=function (){
3     alert(event.keyCode);
4 };
``` 

　　键盘按键的 ctrlKey、shiftKey 和 altKey 快捷属性，可判断是否按下了该键，返回一个布尔值，指示在事件发生时，改键是否被按下。1 表示被按下，0 表示没有按下。

```
 1 document.onkeydown = function (){
 2     if(event.ctrlKey == 1){
 3         alert('Ctrl键被按了');
 4     }
 5     else if(event.shiftKey == 1){
 6         alert('Shift键被按了');
 7     }
 8     else if(event.altKey == true){
 9         alert('Alt键被按了');
10     }
11     else{
12         alert('都没被按下');
13     }
14 };
```

　　　　实例：按键提交消息

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="utf-8" />
 5     <title>JavaScript示例</title>
 6 <script>
 7 window.onload=function (){
 8     var oTxt1 = document.getElementById('txt1');
 9     var oTxt2 = document.getElementById('txt2');
10     var oBtn = document.getElementById('btn1');
11 
12     //点击按钮提交
13     oBtn.onclick = function (){
14         //输入框的值等于文本框的值。
15         oTxt2.value += oTxt1.value + '\n';
16         //清空输入框的值，以便再次输入
17         oTxt1.value = '';
18     };
19 
20 
21     //按Enter或Ctrl+Enter提交
22     oTxt1.onkeydown = function (){
23         //回车键的键码为13
24         if(event.keyCode == 13 || event.keyCode == 13 && event.ctrlKey){
25             oTxt2.value += oTxt1.value + '\n';
26             oTxt1.value = '';
27         }
28     };
29 }
30 </script>
31 </head>
32 <body>
33 <input id="txt1" type="text" >
34 <input id="btn1" type="button" value="提交"><br>
35 <textarea id="txt2" rows="10" cols="50" ></textarea>
36 </body>
37 </html>
```

　　(4)、事件流

　　事件的传递有两种方式：冒泡与捕获。事件传递定义了元素触发事件的顺序。

　　事件冒泡：当一个元素发生事件后，事件会顺着层级（父级 - 父级的父级 --）关系依次向上传递直到 document。

　　事件捕获：事件捕获与事件冒泡正好相反，外部元素的事件会先被触发，然后才会触发内部元素的事件，即从祖先到后代。

　　事件流同时支持两种事件方式，冒泡型事件和捕获型事件，但是捕获型事件先发生。

　　两种事件流会触发 DOM 中的所有对象，从 document 对象开始，也在 document 对象结束。

　　语法：addEventListener('事件名称'，函数，冒泡/捕获)

　　addEventListener()　　方法用于向指定元素添加事件，该方法不会覆盖已存在的事件，可同时向一个元素添加多个事件。该方法有三个参数，第一个参数定义事件的类型，

　　第二个参数规定事件触发后调用的函数，第三个参数是布尔值，用于定义该事件是冒泡还是捕获，若为 false，则表示冒泡事件，若是 ture，则表示捕获事件。

　　这里需要注意是的该方法的事件类型，不需要加”on“，比如平时写点击事件：“onclick”，该方法中则使用“click”即可。

```
 1 <!DOCTYPE html>
 2 <html id="htm">
 3 <head>
 4     <meta charset="utf-8" />
 5     <title>JavaScript示例</title>
 6 <style>
 7 div{padding:50px;}
 8 </style>
 9 <script>
10 window.onload = function (){
11     var x = document.getElementById("div1");
12     var y = document.getElementById("div2");
13     var z = document.getElementById("div3");
14 
15     var o = document.getElementById("bod");
16     var n = document.getElementById("htm");
17 
18     x.addEventListener("click", function() {
19         alert("1冒泡");
20     }, false);
21 
22     y.addEventListener("click", function() {
23         alert("2冒泡");
24     }, false);
25 
26     z.addEventListener("click", function() {
27         alert("3冒泡");
28     }, false);
29 
30     o.addEventListener("click", function() {
31         alert("body捕获");
32     }, true);
33 
34     n.addEventListener("click", function() {
35         alert("html冒泡");
36     }, false);
37 };
38 </script>
39 </head>
40 <body id="bod">
41 <div style="background:lightgreen;margin-bottom:10px;">我是body元素，我捕获。祖先html也会冒泡。</div>
42 <div id="div3" style="background:#ccc;">我是div3，我冒泡
43     <div id="div2" style="background:green;">我是div2,我冒泡
44         <div id="div1" style="background:red;">我是div1,我冒泡</div>
45     </div>
46 </div>
47 </body>
48 </html>
```

　　removeEventListener()　　方法用于移除由 addEventListener() 方法添加的事件监听。这里需要注意在绑定函数时不能使用匿名函数，否则无法删除。

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript示例</title>
 6 <style>
 7 #div1{
 8     background:green;
 9     padding:50px;
10     color:white;
11 }
12 </style>
13 </head>
14 <body>
15 <div id="div1">
16 div元素添加了onmousemove事件监听，鼠标在绿色区域内移动时会显示随机数。
17 <p>点击按钮可移除div的事件监听。</p>
18     <button id="btn1">点击移除</button>
19 </div>
20 <p id="p1"></p>
21 
22 <script>
23 var oDiv = document.getElementById("div1");
24 var oP = document.getElementById("p1");
25 var oBtn = document.getElementById("btn1");
26 
27 oDiv.addEventListener("mousemove", block, false);
28 function block(){
29     oP.innerHTML = Math.random()*10;
30 }
31 oBtn.onclick = function (){
32     oDiv.removeEventListener("mousemove", block, false);
33 };
34 </script>
35 </body>
36 </html>
```

　　cancelBubble　　方法可取消事件冒泡，不会往父级传递。实例：仿百度翻译效果，点击显示按钮显示 div，随便点击页面其他位置隐藏 div。

　　如果不取消事件冒泡，则在点击按钮的同时 div 先是显示了，然后又立马被隐藏了，可以注释掉取消事件冒泡代码，用弹窗查看效果。

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript示例</title>
 6 <style>
 7 #div1{
 8     width:500px;
 9     height:300px;
10     background:lightgreen;
11     display:none;
12 }
13 </style>
14 <script>
15 window.onload = function (){
16     var oBtn = document.getElementById("btn1");
17     var oDiv = document.getElementById("div1");
18 
19     //点击按钮显示div
20     oBtn.onclick = function (){
21         oDiv.style.display = 'block';
22         //alert('显示');
23     
24         //取消事件冒泡，不会往父级传递。
25         event.cancelBubble = true;
26     };
27 
28     //点击document隐藏div
29     document.onclick = function (){
30         oDiv.style.display = 'none';
31     };
32 };
33 </script>
34 </head>
35 <body>
36 <input id="btn1" type="button" value="显示">
37 <div id="div1"></div>
38 </body>
39 </html>
```

　　(5)、默认事件

　　所谓的默认事件，就是浏览器自带的事件。比如按下键盘按键，浏览器会自动将按键值写入输入框。再比如新建一个空白页面在浏览器打开，点击右键出现菜单项。我们并没有用 JS 写相关判断，如果点击右键触发什么事件。这就是浏览器的默认事件，也叫默认行为。如果我们想弹出自定义的右键菜单项，这时候就需要阻止掉浏览器的默认行为，阻止默认事件最简单的写法就是 return false; 。

　　实例：只能输入数字键的输入框，不考虑小键盘区。

　　实现思路：键盘区数字键 0 的键码是 48，1 是 49，9 是 57，那么就可以做出判断，如果按键小于 48 或大于 57，则阻止掉，这说明按下的不是数字键，考虑到写错了需要删除，或者少写了，需要光标移动到少写的位置补上，再移回继续输入，那么就再加上判断条件，如果按键不是退格键或者不是左右方向键，则阻止掉。删除键(退格键)的键码是 8，左方向键是 37，右方向键为 39。

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript示例</title>
 6 <script>
 7 window.onload = function (){
 8     var oTxt = document.getElementById('txt1');
 9     oTxt.onkeydown = function (){
10 
11         //如果按下的不是删除键8，并且不是左方向键37，并且不是右方向键39，并且按键键码小于48或大于57，则阻止掉
12         if(event.keyCode !=8 && event.keyCode != 37 && event.keyCode != 39 && event.keyCode < 48 || event.keyCode > 57){
13             return false;
14         }
15     };
16 };
17 </script>
18 </head>
19 <body>
20 <input id="txt1" type="text" placeholder="请输入数字">
21 </body>
22 </html>
```

### 5、JS 知识点
　　(1)、JS 引擎的预解析机制

　　JS 引擎的解析过程可分为两个阶段：预解析阶段和执行阶段。

　　JS 预解析是在程序进入一个新环境时，把该环境中的变量和函数预解析到他们能调用的环境中，即每一次的预解析单位是一个执行环境。当文档流中有多个 JS 代码段，每个代码段用 ```script``` 标签分隔，包括外部引入的 JS 文件，JS 引擎并非是逐行的解析程序，而是分段进行的，即一个执行环境。预解析不能跨代码段执行，简单说就是不能在一个代码段声明，在另一个代码段调用。

　　变量和函数的预解析就是提升，所谓提升（hoisting），就是 JS 引擎在执行时，默认将所有的变量声明和函数声明都提升到当前作用域的最前边去的行为。所以函数可以在声明之前调用。需要注意的是在使用表达式定义函数时无法提升。

```
 1 <script>
 2 alert(a(2));    //返回：4
 3 function a(x){
 4     return x * x;
 5 }
 6 
 7 alert(b);    //返回：undefined
 8 var b = 'hello'; 
 9 
10 alert(c(2));    //报错
11 //实际上是以变量声明提升
12 //相当于：c(); var c = undefined; c = function (){}
13 var c = function (y){
14     return y * y;
15 }
16 
17 function d(){
18     var n = 'hello';
19 }
20 alert(n);    //报错
21 </script>
```
 

　　通过上面的代码可以看出，function 定义的函数声明 (a) 在代码开始执行之前(预解析阶段)对其实现了函数声明提升，先将其放入内存中，所以在函数声明之前可以调用该函数。和函数声明一样，变量声明 (b) 也会在一开始被放入内存中，但是并没有赋值，所以在他赋值之前，他的值就是 undefined。但是函数表达式 (c) 不同，函数表达式用 var 声明，也就是说解析器会对其变量提升，并对其赋值为 undefined，然后在执行期间，等到执行到该 var 变量的时候再将其变量指向一个 function 函数，所以在函数表达式之前执行该函数就会报错。函数 (d) 是在函数内声明的变量，那么这个变量是属于该函数的私有变量，所以在外部调用时会报错。

　　下面实例实例说明了每一次 JS 预解析的单位是一个执行环境，不会跨一个代码段去执行，直接会报错。

```
1 <script>
2     alert(a);//报错：a is not defined
3 </script>
4 
5 <script>
6     var a = 'hello';
7 </script>
```
 

　　若定义了两个同名的函数 (b)，则在预解析时后面的一个会覆盖掉前边的一个。若变量 (a) 和函数重名 (a)，则函数的优先级高于变量的优先级。

```
 1 <script>
 2 alert(a); //返回：function a(){alert('hi');} 
 3 var a = 'hello'; 
 4 
 5 function a(){
 6     alert('hi');
 7 }
 8 alert(a); //返回：hello
 9 
10 b();    //返回：2
11 function b(){
12     alert(1);
13 }
14 b();    //返回：2
15 function b(){
16     alert(2);
17 }
18 </script>
```

　　(2)、回调函数

　　简单理解，所谓回调，就是回头调用，那么回调函数就是一个函数调用的过程。比如函数 a 有一个参数，这个参数是一个函数 b，当函数 a 执行完以后再执行函数 b，那么这就是一个回调的过程。用官方术语解释就是：回调是一个函数作为参数传递给另一个函数，其母函数完成后执行。那么函数 a 就是母函数。这里需要注意：函数 b 是以参数的形式传递给函数 a 的，那么这个函数 b 就被称为回调函数。回调函数不是由母函数直接调用的，而是在特定的事件或者条件发生时由另外的一方调用，用于对该事件进行响应。回调函数必须使用关键字 callback，并且回调函数本身必须是全局函数。

　　JS 回调的原理是一个异步的流程，在异步调用的情况下使用性能很好，举个简单的例子更能具体的说明，比如朋友要来找你，等到门口了给你打电话。"来找你" 就是函数 a 开始执行，而这时候"你"可以去做任何事情，"到门口"就是函数 a 执行完毕，"给你打电话"这就属于回调函数 b，然后你们就可以一起愉快的玩耍了。

　　下面是一个简单的回调函数实例，点击按钮，当函数 a 执行完成后，分别调用回调函数 b、c、d。

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript示例</title>
 6 <script>
 7 function a(callback){
 8     alert("我是母函数a");
 9     alert("现在要开始调用回调函数");
10     callback();
11 }
12 function b(){
13     alert("我是回调函数b");
14 }
15 function c(){
16     alert("我是回调函数c");
17 }
18 function d(){
19     alert("我是回调函数d");
20 }
21 function back(){
22     a(b);
23     a(c);
24     a(d);
25 }
26 </script>
27 </head>
28 <body>
29 <button onclick="back()">点击按钮</button>
30 </body>
31 </html>
```

　　(3)、自调用函数

　　自调用函数也叫立即执行函数。使用关键字 function 定义一个函数，在给这个函数指定一个函数名，这叫函数声明。使用关键字 function 定义一个函数，未给函数命名，在将这个匿名函数赋值个一个变量，这叫做函数表达式，这也是最常见的函数表达式语法。匿名函数就是使用关键字 function 定义一个函数，但是不给函数命名，匿名函数属于函数表达式。匿名函数有很多作用，可赋予变量创建函数，赋予一个事件则称为事件处理程序。

　　函数声明和函数表达式的区别：JS 引擎在解析 JS 代码时当前执行环境中的函数声明会提升，而函数表达式只能等到 JS 引擎执行到他所在的作用域时，才会逐行的解析函数表达式。函数声明不能使用自调用，而函数表达式可以使用自调用。

　　函数的自调用就是在函数体后加括号，再用括号整个包起来。这样说明该函数是一个函数表达式。
```
1 (function (a, b) {
2     alert(a * b);
3 }(2, 3));    //返回：6
``` 

　　(4)、构造函数

　　函数通过关键字 function 定义，也可以使用关键字 new 定义。函数即对象，对象具有属性和方法，构造函数就是将定义的函数作为某个对象的属性，函数定义作为对象的属性，则称之为对象方法。函数如果用于创建新的对象，就叫做对象的构造函数。

　　(5)、闭包

　　简单理解就是：子函数可以使用父函数中的局部变量。之前好几个例子中都用到了闭包，就是 window.onload 函数下定义的点击事件函数。

　　JS 的变量可以是全局变量或局部变量，在函数之外声明的变量就是全局变量，函数之内声明的变量就是局部变量，私有变量可以用到闭包。函数可以访问全局的变量，也可以访问局部的变量。作用域就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性与生命周期，忽略块级作用域，作用域可分为全局作用域和局部作用域。全局变量是全局对象的属性，局部变量是调用对象的属性。全局变量属于 window 对象，全局变量在任何地方都可以访问，局部变量只能用于定义他的函数内部，这就是 JS 的作用域链，即内层函数可以访问外层函数的局部变量，外层函数不能访问内层函数的局部变量。全局变量和局部变量即便名称相同，他们也是两个不同的变量。修改其中一个，不会修改另一个的值。这里需要注意：在函数内声明的量，如果不使用关键字 var ，那么他就是一个全局变量。

　　所有函数都能访问全局变量，也就是所有的函数都可以访问他上一层的作用域。JS 支持函数嵌套，嵌套函数可以访问上一层的函数变量。闭包就是可以访问上一层函数作用域中的变量函数，即便上一层函数已经关闭。

　　闭包实例解析：

　　如果想实现点击按钮计数，可以声明一个变量，并赋初始值为 0，函数设置值加 1。但是这个全局变量在任何地方都可以使用，即便没有调用这个函数，计数也会改变。

```
 1 <body>
 2 <input type="button" value="全局变量计数" onclick="show()">
 3 <input type="button" value="调用一次变量" onclick="change()">
 4 <p id="p1">0</p>
 5 <script>
 6 var num = 0;
 7 function count() {
 8     return num += 1;
 9 }
10 var oP = document.getElementById("p1");
11 function show(){
12     oP.innerHTML = count();
13 }
14 function change(){
15     alert(num = 10);
16 }
17 </script>
18 </body>
``` 

　　上面例子，每次点击按钮计数正常，但如果调用一次变量，给变量赋值为 10，再点按钮将从 11 开始计数。那么可以将这个变量声明在函数内，如果没有调用这个函数，计数将不会改变。

```
 1 <body>
 2 <input type="button" value="点击计数" onclick="show()">
 3 <p id="p1">0</p>
 4 <script>
 5 function count() {
 6     var num = 0;
 7     return num += 1;
 8 }
 9 var oP = document.getElementById("p1");
10 function show(){
11     oP.innerHTML = count();
12 }
13 </script>
14 </body>
```
 

　　点击按钮可以看到事与愿违，虽然这样不能在函数外部使用变量，也就不能修改计数，但是每次点击按钮值都为 1。因为变量是在函数内声明的，只有该函数可以使用，每点击按钮一次，调用一次该函数，每次调用变量的初始值都为 0，再加 1 就是 1。那么使用 JS 的嵌套函数可以完成这一问题，内嵌函数可以访问父函数的变量。

```
 1 <body>
 2 <input type="button" value="计数" onclick="show()">
 3 <p id="p1">0</p>
 4 <script>
 5 function count(){
 6     var num = 0;
 7     function add(){
 8         num += 1;
 9     }
10     add();
11     return num;
12 }
13 add();    //报错：未定义
14 function show(){
15     document.getElementById("p1").innerHTML = count();
16 }
17 </script>
18 </body>
```
 

　　虽然这样可以解决变量的问题，但是如果可以在外部调用 add() 函数的话，那么点击按钮计数就完美了，梦想总是美好的，现实却是残酷的，内嵌函数不能在外部被调用。这时候我们的闭包就来了，我们需要闭包，有了闭包这个问题就真的完美了。

```
 1 <body>
 2 <input type="button" value="计数" onclick="show()">
 3 <p id="p1">0</p>
 4 <script>
 5 var count = (function (){
 6     var num = 0;
 7     return function (){
 8         return num += 1;
 9     };
10 }());
11 var oP = document.getElementById('p1');
12 function show(){
13     oP.innerHTML = count();
14 }
15 </script>
16 </body>
```
 

　　变量 count 指定了函数自我调用返回值，自我调用函数只执行一次，计数初始值为 0，并返回函数表达式，计数受匿名函数作用域的保护，只能通过 count() 方法修改。

　　变量 count 可以作为一个函数使用，他可以访问函数上一层作用域的计数，这就叫做 JS 闭包，函数拥有自己的私有变量。

## JS DOM
1、DOM 简介
　　当页面加载时，浏览器会创建页面的文档对象模型（Document Object Model）。文档对象模型定义访问和处理 HTML 文档的标准方法。DOM 将 HTML 文档呈现为带有元素、属性和文本的树结构，即节点树。通过 DOM，JS 可创建动态的 HTML，可以使网页显示动态效果并实现与用户的交互功能。JS 能够改变页面中所有的 HTML 元素、属性和 CSS 样式，并对页面中所有事件做出响应。所以学习 JS 的起点就是处理网页，处理网页就需要使用 DOM 进行操作。


2、DOM 获取元素
　　JS 要想操作 HTML 元素，那么首先就必须先找到该元素。通常使用以下几种方法完成：

　　通过元素设置的 id 找到 HTML 元素。

　　通过标签名找到 HTML 元素。

　　通过元素设置的名称 (name) 找到 HTML 元素。

　　所谓的 DOM，实际上就是 document，获取元素就是操作 document。

　　(1)、通过 id 找到元素

　　方法：document.getElementById('id');

　　网页是由标签将信息组合起来的，id 属性值是唯一的，就像身份证一样，通过一个身份证可以找到相对应的人，所以通过该方法，可以获取到与之相对应的标签，而获取的元素在 JS 中是一个对象，若想对元素进行操作，则需要通过他的属性或方法。

　　(2)、通过标签名找到元素

　　方法：document.getElementsByTagName('Tagname');

　　通过该方法，返回的是带有指定标签名的对象的集合，也就是以数组的形式返回，返回的顺序是他们在文档中的顺序。

　　(3)、通过 name 找到元素

　　方法：document.getElementsByName('name');

　　该方法与 getElementById() 方法有点相似，都是通过设置的属性值找到元素，只不过该方法是通过设置的 name 属性值查找元素。name 属性在文档中可能不唯一，所以该方法返回的也是元素的数组，而不是一个元素。

```
 1 <body>
 2 <input name="txt" type="text" value="1">
 3 <input name="txt" type="text" value="2"><br>
 4 <input name="txt" type="text" value="3">
 5 <input name="txt" type="text" value="4"><br>
 6 <input name="txt" type="text" value="5">
 7 <input name="aaa" type="text" value="6">
 8 <script>
 9 //获取所有name值为txt的元素
10 var oTxt = document.getElementsByName("txt");  
11 
12 //获取元素的个数
13 alert(oTxt.length);       //返回：5
14 
15 //获取第二个元素的值
16 alert(oTxt[1].value);    //返回：2
17 </script>
18 </body> 
```

　　既然可以通过 id 找到元素，那么也就可以通过 class 找到元素。className 属性用于设置或者返回元素的 class 类名。

　　语法：object.className = 'className'

　　该方法可以控制 class 类名，返回元素的 class 属性，作用是可以为网页中某个元素指定一个 className 来更改该元素的外观。

　　实例：简单的网页换肤效果

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>网页换肤</title>
 6 <style>
 7 body{
 8     background:lightgreen;
 9 }
10 .col1{
11     background:lightgray;
12 }
13 .col2{
14     background:lightblue;
15 }
16 .col3{
17     background:violet;
18 }
19 .col4{
20     background:pink;
21 }
22 .col5{
23      background:#f93;
24 }
25 </style>
26 </head>
27 <body id="boy">
28 点击切换：<input type="button" value="灰色" onclick="gr()">
29 <input type="button" value="蓝色" onclick="bl()">
30 <input type="button" value="紫色" onclick="vi()">
31 <input type="button" value="粉色" onclick="pi()">
32 <input type="button" value="橘色" onclick="or()">
33 <script>
34 var x = document.getElementById('boy');
35 function gr(){
36     x.className = 'col1';
37 }
38 
39 function bl(){
40     x.className = 'col2';
41 }
42 
43 function vi(){
44     x.className = 'col3';
45 }
46 
47 function pi(){
48     x.className = 'col4';
49 }
50 
51 function or(){
52     x.className = 'col5';
53 }
54 </script>
55 </body>
56 </html>
```

　　这只是一个简单的切换背景色效果，如果想切换网页的整体样式，可以使用外部 CSS 文件，通过 JS 改变 link 标签的 href 属性来完成。

　　如果想设置多个 class 类名相同的元素的样式，就需要借助数组的方法来完成，其实现原理也很简单，首先通过 id 获取其父元素，再获取父元素下所有子元素的标签名，获取标签名返回的是元素的数组，所以就可以和访问数组一样的方法来访问元素的数组，那么先使用循环遍历该元素数组，再做判断，如果这个元素的 className 等于我们设置的 class 属性值，就说明这是我们要找的元素。

　　实例：将有序列表中所有 class 属性值为"col"的元素背景颜色设置为绿色

```
 1 <body>
 2 <ol id="o1">
 3     <li>热点</li>
 4     <li class="col">美食</li>
 5     <li>数码</li>
 6     <li class="col">科技</li>
 7     <li>社会</li>
 8     <li class="col">养生</li>
 9 </ol>
10 <script>
11 //通过id获取父元素
12 var aOl = document.getElementById('o1');
13 //通过标签名获取父元素下所有子元素
14 var oLi = aOl.getElementsByTagName('li');
15 //循环遍历返回的子元素数组
16 for(var i=0; i<oLi.length; i++){
17     //如果当前子元素的className等于设置的class属性值，则将其背景设置为绿色
18     if(oLi[i].className == 'col') oLi[i].style.background = 'green';
19 }
20 </script>
21 </body>
```

　　下面是一个通过 class 属性值获取元素的封装函数，方便以后使用。

```
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>封装getByClass函数</title>
 6 <script>
 7  //第一个参数为获取的父元素，第二个参数为class属性值。
 8  function getByClass(oParent,aClass){
 9     //空数组可以把找到的所有className都存放在里边，最后返回。
10     var aResult = [];
11     //通过标签名获取父元素下所有子元素。标签名不固定，所以设置为*，便于传入。
12     var aEle = oParent.getElementsByTagName('*');
13     //循环遍历返回的子元素数组
14     for(var i=0; i<aEle.length; i++){
15         //如果当前子元素的className等于传入的class属性值，则将其添加到数值中。
16         if(aEle[i].className == aClass) aResult.push(aEle[i]);
17     }
18     //最后将这个数组返回
19     return aResult;
20 }
21 </script>
22 </head>
23 <body>
24 <ol id="o1">
25     <li>热点</li>
26     <li class="col">美食</li>
27     <li>数码</li>
28     <li class="col">科技</li>
29     <li>社会</li>
30     <li class="col">养生</li>
31  </ol>
32 <script>
33 //封装函数的使用：
34 //先通过id获取父元素
35 var aOl = document.getElementById('o1');
36 //再调用封装好的函数传入参数，获取的父元素，子元素的class属性值
37 var oCol = getByClass(aOl,'col');
38 //最后循环遍历，设置样式
39 for(var i=0; i<oCol.length; i++){
40     oCol[i].style.background = 'green';
41 }
42 </script>
43 </body>
44 </html>
```
 

3、DOM操作
　　获取到 HTML 元素之后，就可以进行相应的操作。

　　(1)、改变HTML

　　修改 HTML 内容的最简单的方法时使用 innerHTML 属性。innerHTML 顾名思义，inner 就是内部的，既然是 HTML，那么就可以给里边放 HTML。该属性可用于获取和替换 HTML 元素的内容。

　　语法：document.getElementById(id).innerHTML = new HTML

复制代码
 1 <body>
 2 <h1 id="tit">原标题</h1>
 3 <script>
 4 //改变原有标题
 5 var aH = document.getElementById('tit');
 6 aH.innerHTML = '新标题';
 7 </script>
 8 
 9 <div id="div1" style="width:500px;height:200px;border:1px solid black;"></div>
10 <script>
11 //创建HTML内容
12 var oDiv = document.getElementById('div1');
13 oDiv.innerHTML = '<h2>我是h2标题</h2><p>我是一个段落</p>';
14 </script>
15 </body>
复制代码
 

　　(2)、操作元素属性

　　修改元素属性最简单的方法就是直接修改，语法：document.getElementById(id).属性名 = new value　比如修改图片src属性的指向路径。

　　此外还可以通过DOM方法获取、添加、删除元素的属性。

　　①、getAttribute()

　　getAttribute()　　方法通过元素节点的属性名获取属性的值。

　　语法：elementNode.getAttribute(name)　　name是想要获取的元素节点的属性名

　　②、setAttribute()

　　setAttribute()　　方法添加一个新属性并指定值，或者把一个现有的属性设定为指定的值。

　　语法：elementNode.setAttribute(name,value)　　name是属性名，value是属性值。

　　③、removeAttribute()

　　removeAttribute()　　方法可删除元素的属性。

　　语法：elementNode.removeAttribute(name)　　name是属性名。

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 </head>
 7 <body>
 8 <input id="txt1" type="text">
 9 <input id="btn1" type="button" value="按钮">
10 <script>
11 var oTxt = document.getElementById('txt1');
12 var oBtn = document.getElementById('btn1');
13 
14 //获取按钮value属性的值
15 var a = oBtn.getAttribute('value');
16 alert(a);    //返回：按钮
17 
18 oBtn.onclick = function (){
19     //操作元素属性有三种方法：
20     //第一种方法
21     //oTxt.value='请输入文字';
22 
23     //第二种方法
24     //oTxt['value']='请输入文字';
25 
26     //第三种方法
27     //修改文本框value属性的值
28     oTxt.setAttribute('value','请输入文字');
29 
30     //删除按钮type属性
31     oBtn.removeAttribute('type');
32     //删除后默认为文本框
33 };
34 </script>
35 </body>
36 </html>
复制代码
 

　　(3)、改变CSS

　　改变 HTML 元素的 CSS 样式可直接使用该语法：document.getElementById(id).style.样式名 = new style

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 <style>
 7 #div1{
 8     height:400px;
 9     width:600px;
10     border:1px solid black;
11     padding:5px;
12 }
13 p{
14     line-height:18px;
15     text-indent:2em;
16 }
17 </style>
18 </head>
19 <body>
20 <h2>HTML DOM</h2>
21 <div id="div1">
22     <h3>JS可以使网页添加动态效果并实现与用户交互的功能。</h3>
23     <p>1. JS能够改变页面中所有的 HTML 元素。</p>
24     <p>2. JS能够改变页面中所有的 HTML 属性。</p>
25     <p>3. JS能够改变页面中所有的 HTML 元素的CSS样式。</p>
26 </div>
27 
28 <input type="button" value="改变颜色" onclick="color()">
29 <input type="button" value="改变宽高" onclick="hig()">
30 <input type="button" value="隐藏内容" onclick="none()">
31 <input type="button" value="显示内容" onclick="block()">
32 <input type="button" value="取消设置" onclick="cancel()">
33 
34 <script>
35 var oDiv = document.getElementById('div1');
36 function color(){
37     oDiv.style.color = 'white';
38     oDiv.style.fontFamily = 'Microsoft YaHei';
39     oDiv.style.backgroundColor = 'green';
40 }
41 
42 function hig(){
43     oDiv.style.width = '400px';
44     oDiv.style.height = '300px';
45     oDiv.style.border = '5px solid #ccc';
46 }
47 
48 function none(){
49     oDiv.style.display = 'none';
50 }
51 
52 function block(){
53     oDiv.style.display = 'block';
54 }
55 
56 //取消设置
57 function cancel(){
58     var clean = confirm('确定取消所有设置？');
59     if(clean == true){
60         oDiv.removeAttribute('style');
61     }
62 }
63 </script>
64 </body>
65 </html>
复制代码
 

　　上面的代码，通过 style 设置的样式，都是行间样式，可以使用火狐的 Firebug 点击相应的按钮，就能看到所有设置的 CSS 样式都出现在了行间。

　　可以直接通过 style 获取和设置 CSS 样式，那么有没有更简洁的方法呢？可以借助于函数使用 JS 的内置对象 arguments 完成，所谓 arguments，就是可变参，不定参，参数的个数可变，是一个参数数组，无需指出参数名，就可访问他们，但是为了增强可读性，给参数取名，还是很有必要的。

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 </head>
 7 <body>
 8 <div id="div1" style="width:200px;height:200px;background:red"></div>
 9 <script>
10 //获取行间样式
11 function css(){
12     //如果传入参数的个数等于2
13     if(arguments.length == 2){
14         //则返回第二个参数样式名的值
15         return arguments[0].style[arguments[1]];
16     }
17     else{
18         //否则就是设置CSS样式
19         //第二个参数样式名的值就等于传入的第三个参数
20         arguments[0].style[arguments[1]] = arguments[2];
21     }
22 }
23 
24 var oDiv = document.getElementById('div1');
25 alert(css(oDiv,'width'));    //获取对象的宽 返回：200px
26 css(oDiv,'background','green');    //将对象的背景颜色改为绿色
27 </script>
28 </body>
29 </html>
复制代码
 

　　下面是一个获取和设置行间样式的封装函数，以便以后使用。

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>获取行间样式</title>
 6 <script>
 7 function css(obj, name, value){
 8     if(arguments.length == 2){
 9         return obj.style[name];
10     }
11     else{
12         obj.style[name] = value;
13     }
14 }
15 </script>
16 </head>
17 <body>
18 <div id="div1" style="width:200px;height:200px;background:red"></div>
19 <script>
20 var oDiv = document.getElementById('div1');
21 alert(css(oDiv,'width'));    //获取div的宽
22 css(oDiv,'background','green');    //设置div的背景颜色
23 </script>
24 </body>
25 </html>
复制代码
 

　　我们都知道，在实际的 Web 项目开发中，要遵循结构、表现、行为相分离的原则，以增强可读性，优化代码，便于后期维护。所以通常我们设置元素的样式，并非都是在行间设置。使用 style 方法获取的只是 DOM 元素 style 属性里的样式规则，对于通过 class 属性设置的外部样式表，style 就显得力不从心了。那要如何获取元素的非行间样式呢？DOM 标准中有个全局方法 getComputedStyle，通过该方法可以获取当前对象的样式信息。比如：getComputedStyle(obj, false).paddingLeft，可以获取到对象的左内边距。这里需要注意：在获取元素的复合样式时，一定要使用精确的值，复合样式比如 background、border，如果要获取元素的背景颜色，只使用 background 会出错，一定要写成 backgroundColor。

　　JS 只能修改元素的行间样式，并不能修改获取到的非行间样式。那么很多人可能会产生疑问，既然可以获取到又不能修改，那还获取有什么用。其实获取非行间样式是非常有必要的，如果是外部样式表，样式都是密密麻麻一片英文的存在，不可能一个个去找，到底该元素设置的什么样子，再回头修改，那岂不是太浪费精力了，所以该方法就显得尤为重要，而且返回的值都是精确值，通过获取的非行间样式信息，也有利于更精细的修改元素的当前样式，这是多么美妙的一件事，直接使用 style 设置元素的行间样式，因为行间样式的优先级最高，所以就覆盖掉了非行间样式，其实也就相当于跟修改了非行间样式一样，只是显示在了行间，我们的目的反着是已经达到了。

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>获取非行间样式</title>
 6 <style>
 7 #div1{
 8     width:200px;
 9     height:200px;
10     background:red;
11     margin-top:10px;
12 }
13 </style>
14 <script>
15 window.onload = function (){
16     var oDiv = document.getElementById('div1');
17 
18     alert(getComputedStyle(oDiv,false).width);
19     oDiv.style.width = '400px';
20 
21     alert(getComputedStyle(oDiv,false).height);
22     oDiv.style.height = '400px';
23 
24     //注意这里修改复合样式时，使用的background，可在FF下用Firebug查看具体的行间样式。
25     alert(getComputedStyle(oDiv,false).backgroundColor);
26     oDiv.style.background = 'green';
27 };
28 </script>
29 </head>
30 <body>
31 <div id="div1"></div>
32 </body>
33 </html>
复制代码
 

　　(4)、对事件做出响应

　　实例：全选和反选，输入对应的序号选中

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 </head>
 7 <body>
 8 <form id="list">
 9     请选择你的业余爱好:<br>
10     1. 音乐<input type="checkbox" name="love" id="like1">
11     2. 阅读<input type="checkbox" name="love" id="like2">
12     3. 游泳<input type="checkbox" name="love" id="like3">
13     4. 篮球<input type="checkbox" name="love" id="like4">
14     5. 足球<input type="checkbox" name="love" id="like5">
15     6. 散步<input type="checkbox" name="love" id="like6">
16     7. 泡吧<input type="checkbox" name="love" id="like7">
17     8. 逛街<input type="checkbox" name="love" id="like8"><br>
18     <input type="button" value = "全选" onclick="optAll()">
19     <input type="button" value = "反选" onclick="noAll()">
20 
21     <p>输入1-8序号选择，每次只可以选择一项：</p>
22     <input id="txt1" type="text">
23     <input id="btn1" type="button" value="确定">
24 </form>
25 <script>
26 function optAll(){
27     //通过获取标签名设置全选
28     var oList = document.getElementById('list');
29     var aCheck = oList.getElementsByTagName('input');
30     for(var i=0; i<aCheck.length; i++){
31         if(aCheck[i].type == 'checkbox'){
32             aCheck[i].checked = true;
33         }
34     }
35 }
36 
37 function noAll(){
38     //通过获取设置的name属性值设置反选
39     var aLove = document.getElementsByName('love');  
40     for(var i=0; i<aLove.length; i++){
41         if(aLove[i].type == 'checkbox'){
42             aLove[i].checked = false;
43         }
44     }
45 }
46 
47 var oBtn = document.getElementById('btn1');
48 //给获取的按钮添加点击事件
49 oBtn.onclick = function (){
50     //获取文本框输入的值
51     var oTxt = document.getElementById("txt1").value;
52     //定义的复选框id值为like1-8。括号中进行的是字符串连接，id+输入到文本框的值=该元素的id值
53     var oLike = document.getElementById('like' + oTxt);
54     oLike.checked = true;
55 }
56 </script>
57 </body>
58 </html>
复制代码
 

3、DOM节点
　　HTML 文档可以说是由节点构成的集合，常见的 DOM 节点有三种，即元素节点、属性节点和文本节点。元素节点就是 HTML 标签，标签的属性就是属性节点，文本节点就是页面可以浏览的内容。

　　在文档对象模型中，每一个节点都是一个对象，DOM 节点有三个重要的属性：节点的名称，节点的值和节点的类型。

　　(1)、nodeName：节点的名称

　　nodeName 属性返回节点的名称。元素节点的名称与标签名相同(大写)，属性节点的名称是属性的名称，文本节点的名称永远都是 #text，文档节点的名称永远都是 #document。

　　(2)、nodeValue：节点的值

　　nodeValue 属性返回节点的值。元素节点的值是 undegined 或 null，属性节点的值是属性的值，文本节点的值是文本自身。

　　(3)、nodeType：节点的类型

　　nodeType 属性返回节点的类型。以下是常见的节点类型：

节点类型	说明	值
元素节点	每一个HTML标签都是一个元素节点，如 <div> 、 <p>、<ul>等	1
属性节点	元素节点（HTML标签）的属性，如 id 、class 、name 等。	2
文本节点	元素节点或属性节点中的文本内容。	3
注释节点	表示文档注释，形式为<!-- text content -->。	8
文档节点	表示整个文档（DOM 树的根节点，即 document ）。	9
 

　　综合实例：

复制代码
 1 <body>
 2 <ul>
 3     <li>JS</li>
 4     <li>DOM</li>
 5 </ul>
 6 <script>
 7 var nodes = document.getElementsByTagName('li');
 8 for(var i=0; i<nodes.length; i++){
 9     document.write('第' + (i+1) + '个节点的名称是' + nodes[i].nodeName + '<br>');
10     document.write('第' + (i+1) + '个节点的值是' + nodes[i].nodeValue + '<br>');
11     document.write('第' + (i+1) + '个节点的类型是' + nodes[i].nodeType + '<br>');
12     document.write('<br>');
13 } 
14 
15 /*
16 返回：
17 第1个节点的名称是LI
18 第1个节点的值是null
19 第1个节点的类型是1
20 
21 第2个节点的名称是LI
22 第2个节点的值是null
23 第2个节点的类型是1
24 */
25 </script>
26 </body>
复制代码
 

　　JS 中函数可以嵌套使用，有父函数有子函数，HTML 标签也可以嵌套使用，那么就说明存在着各种不同的节点关系，比如父节点、子节点和兄弟节点。为了方便操作，DOM定义了一些节点的公共属性。

　　(1)、子节点

　　childNodes 属性返回节点的子节点集合，可使用length属性返回子节点的数量，然后就可以和数组一样获取需要的信息。

复制代码
 1 <body>
 2 <ul id="u1">
 3     <li>1</li>
 4     <li>2</li>
 5     <li>3</li>
 6     <li>4</li>
 7     <li>5</li>
 8 </ul>
 9 <script>
10 var oUl = document.getElementById('u1');
11 alert(oUl.childNodes.length);    //返回：11
12 </script>
13 </body>
复制代码
 

 　　通过上面的代码，可以看到返回的是 11。ul 下明明只有 5 个 li 元素，怎么会返回 11 呢？其实是这么回事：

复制代码
1 <ul id="u1">   第1个节点（文本节点）
2     <li>第2个节点（元素节点）</li> 第3个节点（文本节点）
3     <li>第4个节点（元素节点）</li> 第5个节点（文本节点）
4     <li>第6个节点（元素节点）</li> 第7个节点（文本节点）
5     <li>第8个节点（元素节点）</li> 第9个节点（文本节点）
6     <li>第10个节点（元素节点）</li> 第11个节点（文本节点）
7 </ul>
复制代码
 

　　因为通过 childNodes 属性返回的子节点集合，不仅包括元素节点，而且还包括文本节点，浏览器会将标签之间的空白默认为文本节点，如果在空白处输入文字，就会显示在页面上，这就造成了不必要的麻烦，所以建议使用 children 属性，该属性只返回元素节点，不包括文本节点，并且不包括注释节点。

复制代码
 1 <body>
 2 <ul id="u1">
 3     <li>
 4         我是个文本节点
 5         <span>我是span元素。</span>
 6     </li>
 7     <li></li>    <!-- 注释 -->
 8     <li></li>
 9     <li></li>
10     <li></li>
11 </ul>
12 <script>
13 var oUl = document.getElementById('u1');
14 alert(oUl.children.length);    //返回：5
15 </script>
16 </body>
复制代码
　　上面的代码，ul 下有 5 个 li 元素，返回子节点个数为 5。children 属性要比 childNodes 属性好用太多了，只返回元素的子节点，还不包括孙子辈节点。

　　(2)、首尾子节点

　　firstElementChild 属性返回 children 数组的第一个节点。

　　语法：node.firstElementChild　　该方法相当于：element.children[0]

 

　　lastElementChild 属性返回 children 数组的最后一个节点。

　　语法：node.lastElementChild　　该方法相当于：element.children[element.children.length-1]

复制代码
 1 <body>
 2 <div style="border:2px solid green" id="div1">
 3    空白节点
 4   <p>JS</p>
 5   <div>DOM</div>
 6   <h3>jQuery</h3>
 7 </div>
 8 <script>
 9 var x = document.getElementById('div1');
10 document.write('第一个节点的名称：' + x.firstElementChild.nodeName + '<br>');
11 //返回：第一个子节点的名称：P
12 document.write('最后一个节点的名称：' + x.lastElementChild.nodeName)
13 //返回：最后一个子节点的名称：H3
14 </script>
15 </body>
复制代码
 

　　(3)、父节点

　　parentNode 属性用于获取指定节点的父节点。注意：父节点只能有一个。通过使用两个获取父节点，可获取祖节点。

　　实例：点击子节点，隐藏父节点

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 </head>
 7 <body>
 8 <ul id="u1">
 9     <li>aaa <a href="javascript:;">点击隐藏</a></li>
10     <li>bbb <a href="javascript:;">点击隐藏</a></li>
11     <li>ccc <a href="javascript:;">点击隐藏</a></li>
12     <li>ddd <a href="javascript:;">点击隐藏</a></li>
13     <li>eee <a href="javascript:;">点击隐藏</a></li>
14 </ul>
15 <script>
16 var oUl = document.getElementById('u1');
17 //查看ul元素的父节点
18 alert(oUl.parentNode);    //返回：[object HTMLBodyElement]
19 
20 //通过标签名获取所有的a元素
21 var aA = document.getElementsByTagName('a');
22 for(var i=0; i<aA.length; i++){
23     aA[i].onclick = function (){
24         //设置当前节点的父节点为隐藏
25         this.parentNode.style.display = 'none';
26     };
27 }
28 </script>
29 </body>
30 </html>
复制代码
 

　　offsetParent 属性可返回一个元素用于定位的父级。

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 <style>
 7 #div1{
 8     width:200px;
 9     height:200px;
10     background:green;
11     margin:100px;
12     /*position:relative;*/
13 }
14 #div2{
15     width:100px;
16     height:100px;
17     background:red;
18     position:absolute;
19     left:50px;
20     top:50px;
21 }
22 </style>
23 </head>
24 <body>
25 <div id="div1">
26     <div id="div2"></div>
27 </div>
28 <script>
29 var oDiv2 = document.getElementById('div2');
30 alert(oDiv2.offsetParent);
31 //返回：[object HTMLBodyElement]
32 
33 //div2的父级是div1,如果取消div1相对定位的注释。则返回：[object HTMLDivElement]
34 </script>
35 </body>
36 </html>
复制代码
 

　　(3)、兄弟节点

　　nextElementSibling 属性返回同一树层级中某个节点之后紧跟的节点。

　　语法：element.nextElementSibling　　

 

　　previousElementSibling 属性返回同一树层级中某个节点之前紧跟的节点。

　　语法：element.previousElementSibling

 

　　实例：获取 li 元素节点的兄弟节点

复制代码
 1 <body>
 2 <ul>   
 3     <li>HTML</li>   
 4     <li>CSS</li>
 5     <li>JS</li>   
 6 </ul>     
 7 <script>
 8 var aLi = document.getElementsByTagName('li');
 9 //获取第二个子节点之后紧跟的节点
10 var x = aLi[1].nextElementSibling;
11 alert(x.innerHTML);    //返回：JS
12 
13 //获取第二个子节点之前紧跟的节点
14 var y = aLi[1].previousElementSibling;
15 alert(y.innerHTML);    //返回：HTML
16 </script>
17 </body>
复制代码
 

4、DOM 应用
　　DOM 最实际的应用就是可以通过 JS 创建、插入和删除节点。

　　(1)、创建节点

　　createElement() 方法可创建元素节点。

　　语法：document.createElement(tagName)

 

　　appendChild()方法可在指定节点的末尾插入一个新的子节点，每次都向末尾添加。

　　语法：父级.appendChild(new node)

 

　　实例：创建并添加 li 元素

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 <script>
 7 window.onload = function (){
 8     var oBtn = document.getElementById('btn1');
 9     var oUl = document.getElementById('u1');
10     var oTxt = document.getElementById('txt1');
11 
12     //文本框输入提示
13     oTxt.placeholder = '请输入文字创建li元素';
14 
15     oBtn.onclick = function (){
16         //创建li元素
17         var oLi = document.createElement('li');
18 
19         //创建的li元素的HTML=文本框输入的值
20         oLi.innerHTML = oTxt.value;
21 
22         //插入到oUl父级下，作为子节点，在每个创建的li末尾插入新创建的li元素
23         oUl.appendChild(oLi);
24         //父级.appendCild(子节点);
25     };
26 };
27 </script>
28 </head>
29 <body>
30 <input id="txt1" type="text"value="">
31 <input id="btn1" type="button"value="创建li">
32 <ul id="u1"></ul>
33 </body>
34 </html>
复制代码
 

　　(2)、插入节点

　　insertBefore() 方法可在已有的子节点前插入一个新的子节点。

　　语法：父级.insertBefore(new node, node)　　第一个参数为要插入的新子节点。第二个参数是原有节点，也就是在谁之前插入。

　　实例：创建并添加 li 元素，每个新创建的 li 元素都插入到之前插入的 li 元素之前

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 <script>
 7 window.onload = function (){
 8     var oBtn = document.getElementById('btn1');
 9     var oUl = document.getElementById('u1');
10     var oTxt = document.getElementById('txt1');
11 
12     oBtn.onclick = function (){
13         //创建li元素
14         var oLi = document.createElement('li');
15         //获取所有li元素
16         var aLi = oUl.getElementsByTagName('li');
17         oLi.innerHTML = oTxt.value;
18 
19         //这里需要注意：页面中本没有li元素，li元素是通过JS创建的
20         //所以第一个li元素应该添加到父级下最后一个子节点
21         //然后基于这个节点，将之后再插入的子节点插入到上一个节点之前
22 
23         //如果li元素本来不存在，则执行else，在父级插入一个子节点。
24         //如果li元素的个数>0，说明已经创建了，则插入到这个子节点之前。
25         if(aLi.length>0){
26             oUl.insertBefore(oLi,aLi[0]);
27         }
28         else{
29             oUl.appendChild(oLi);
30         }
31     };
32 };
33 </script>
34 </head>
35 <body>
36 <input id="txt1" type="text" value="">
37 <input id="btn1" type="button" value="创建li">
38 <ul id="u1"></ul>
39 </body>
40 </html>
复制代码
 

　　(4)、删除节点

　　removeChild() 方法用于删除一个节点

　　语法：父级.removeChild(node)　　参数为要删除的子节点。

　　实例：简单的表格添加和删除

复制代码
  1 <!DOCTYPE html>
  2 <html>
  3 <head>
  4     <meta charset="UTF-8">
  5     <title>JavaScript实例</title>
  6 <script>
  7 window.onload = function (){
  8     var oTab = document.getElementById('tab1');
  9     var oName = document.getElementById('user');
 10     var oAge = document.getElementById('age');
 11     var oBtn = document.getElementById('btn1');
 12     
 13     //设置添加的ID项的值
 14     var id = oTab.tBodies[0].rows.length+1;
 15 
 16     oBtn.onclick = function (){
 17         //创建一个tr
 18         var oTr = document.createElement('tr');
 19         //创建第一个td（ID项）
 20         var oTd = document.createElement('td');
 21         //获取ID，已经删除的ID号，不能再重用。
 22         oTd.innerHTML = id++;
 23         //将创建的td放入创建的tr中
 24         oTr.appendChild(oTd);
 25 
 26         //创建第二个td（姓名项）
 27         var oTd = document.createElement('td');
 28         oTd.innerHTML = oName.value;
 29         oTr.appendChild(oTd);
 30 
 31         //创建第三个td（年龄项）
 32         var oTd = document.createElement('td');
 33         oTd.innerHTML = oAge.value;
 34         oTr.appendChild(oTd);
 35 
 36         //创建第四个td（操作项）
 37         var oTd = document.createElement('td');
 38         oTd.innerHTML = '<a href="javascript:;">删除</a>';
 39         oTr.appendChild(oTd);
 40 
 41         oTd.getElementsByTagName('a')[0].onclick = function (){
 42             //删除整行
 43             oTab.tBodies[0].removeChild(this.parentNode.parentNode);
 44         };
 45 
 46         //将创建好的tr放入tbody中
 47         oTab.tBodies[0].appendChild(oTr);
 48     };
 49 };
 50 </script>
 51 </head>
 52 <body>
 53 姓名：<input id="user"type="text">
 54 年龄：<input id="age"type="text">
 55 <input id="btn1" type="button" value="添加">
 56 <table id="tab1" border="1" width="500px">
 57     <caption>员工表</caption>
 58     <thead>
 59         <tr>
 60             <th>ID</th>
 61             <th>姓名</th>
 62             <th>年龄</th>
 63             <th>操作</th>
 64         </tr>
 65     </thead>
 66     <tbody>
 67         <tr>
 68             <td>1</td>
 69             <td>小白</td>
 70             <td>27</td>
 71             <td></td>
 72         </tr>
 73         <tr>
 74             <td>2</td>
 75             <td>小明</td>
 76             <td>25</td>
 77             <td></td>
 78         </tr>
 79         <tr>
 80             <td>3</td>
 81             <td>小红</td>
 82             <td>21</td>
 83             <td></td>
 84         </tr>
 85         <tr>
 86             <td>4</td>
 87             <td>张三</td>
 88             <td>29</td>
 89             <td></td>
 90         </tr>
 91         <tr>
 92             <td>5</td>
 93             <td>李四</td>
 94             <td>35</td>
 95             <td></td>
 96         </tr>
 97     </tbody>
 98 </table>
 99 </body>
100 </html>
复制代码
 

　　这个实例只能很简单的完成添加和删除，并不对输入进行判断，如果想要做的完美，还需要做很多工作，可以对表格进行美化，设置背景色，鼠标移入高亮显示，鼠标移出恢复背景色，最关键的就是要对表单输入内容进行判断，以确保每次提交的信息都是有效信息，如果表格信息量大，还可以添加支持模糊搜素，多关键字搜索，以提高用户体验度，当然在实际的项目中，这样的情况几乎不会出现，但可以作为自己的实践，检验学习成果。

　　(5)、替换节点和创建文本节点

　　replaceChild() 方法可用于替换元素节点。

　　语法：node.replaceChild (new node, node)　　第一个参数为用于替换的节点。第二个参数为原有节点。

 

　　createTextNode() 方法可创建新的文本节点，返回新创建的 Text 节点。

　　语法：document.createTextNode(txt)

　　这两种方法平时几乎用不到，但还是需要了解。

　　实例：点击按钮将 span 标签替换为 b 标签。再创建一个文本节点插入到创建的 p 元素下，并设置 className

复制代码
 1 <!DOCTYPE html>
 2 <html>
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>JavaScript实例</title>
 6 <style>
 7 .p1{
 8     width:300px;
 9     height:100px;
10     background-color:#ccc;
11 }    
12 </style>
13 </head>
14 <body>
15 <p>创建一个P标签，设置<span id="s">className</span>属性，创建文本节点。</p>
16 <input type="button" value="点击替换" onclick="change()">
17 <script>
18 function change(){
19     //获取span元素
20     var oS = document.getElementById('s');
21     //创建一个b元素
22     var newNode = document.createElement('b');
23     //要替换的文本节点
24     var txt = document.createTextNode('className');
25     //将文本节点插入到创建的b元素下
26     newNode.appendChild(txt);
27     //在span元素的父级下将span元素替换成新创建的b元素
28     oS.parentNode.replaceChild(newNode,oS);
29 }
30 
31 //创建一个p元素
32 var oP = document.createElement('p');
33 //设置className
34 oP.className = 'p1';
35 //创建文本节点
36 var txtNode = document.createTextNode('createTextNode用于创建文本节点!');
37 //将创建的文本节点插入到p元素下
38 oP.appendChild(txtNode);
39 //再将p元素插入到父级body下
40 document.body.appendChild(oP);
41 </script> 
42 </body>
43 </html>